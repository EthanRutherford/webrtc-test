{"entry":"/src/box.js","files":{"src":{"box.js":{"/code":"const fork=require(\"./framework/fork\"),Math=require(\"./framework/math\"),Solver=require(\"./framework/solver\"),Joint=require(\"./joints/joint\"),RevJoint=require(\"./joints/revjoint\"),RopeJoint=require(\"./joints/ropejoint\"),SpringJoint=require(\"./joints/springjoint\"),WheelJoint=require(\"./joints/wheeljoint\"),Body=require(\"./objects/body\"),Circle=require(\"./objects/circle\"),Polygon=require(\"./objects/polygon\"),{Shape:Shape,AABB:AABB}=require(\"./objects/shape\");module.exports={fork:fork,Math:Math,Solver:Solver,Body:Body,AABB:AABB,Shapes:{Shape:Shape,Circle:Circle,Polygon:Polygon},Joints:{Joint:Joint,RevJoint:RevJoint,RopeJoint:RopeJoint,SpringJoint:SpringJoint,WheelJoint:WheelJoint}};"},"objects":{"shape.js":{"/code":"const{Vector2D:Vector2D}=require(\"../framework/math\");let next=0;class AABB{constructor(t=0,i=0,m=0,n=0){this.min=new Vector2D(t,i),this.max=new Vector2D(m,n)}test(t){return!(this.max.x<t.min.x||this.min.x>t.max.x||this.max.y<t.min.y||this.min.y>t.max.y)}contains(t){return!(this.max.x<t.max.x||this.min.x>t.min.x||this.max.y<t.max.y||this.min.y>t.min.y)}get perimeter(){return 2*(this.max.x-this.min.x+this.max.y-this.min.y)}combine(t){return new AABB(Math.min(this.min.x,t.min.x),Math.min(this.min.y,t.min.y),Math.max(this.max.x,t.max.x),Math.max(this.max.y,t.max.y))}clone(){return new AABB(this.min.x,this.min.y,this.max.x,this.max.y)}}class Shape{constructor(){this.id=next++}static order(t,i){return t.id<i.id?[t,i]:[i,t]}}module.exports={AABB:AABB,Shape:Shape};"},"polygon.js":{"/code":"const{Vector2D:Vector2D}=require(\"../framework/math\"),MassData=require(\"./mass\"),{AABB:AABB,Shape:Shape}=require(\"./shape\"),inv3=1/3;module.exports=class t extends Shape{constructor(){super(),this.body=null,this.aabb=new AABB,this.points=[],this.norms=[]}setAsBox(t,s){return this.points.push(new Vector2D(-t,-s)),this.points.push(new Vector2D(t,-s)),this.points.push(new Vector2D(t,s)),this.points.push(new Vector2D(-t,s)),this.norms.push(new Vector2D(0,-1)),this.norms.push(new Vector2D(1,0)),this.norms.push(new Vector2D(0,1)),this.norms.push(new Vector2D(-1,0)),this.originalPoints=this.points.map(t=>t.clone()),this}set(t){if(t.length<3)throw new Error(\"Can't create polygon with fewer than 3 points\");let s=0,i=t[0].x;for(let n=1;n<t.length;n++){const o=t[n].x;o>i?(i=o,s=n):o===i&&t[n].y<t[s].y&&(s=n)}const n=[];let o=s;for(;;){n.push(o);let i=0;for(let s=1;s<t.length;s++){if(i===o){i=s;continue}const n=t[i].minus(t[o]),e=t[s].minus(t[o]),r=n.cross(e);(r<0||0===r&&e.lsqr>n.lsqr)&&(i=s)}if(o=i,i===s)break}for(const s of n)this.points.push(t[s].clone());for(let t=0;t<this.points.length;t++){const s=t+1<this.points.length?t+1:0,i=this.points[s].minus(this.points[t]),n=i.y;i.y=-i.x,i.x=n,this.norms.push(i.normalize())}return this.originalPoints=this.points.map(t=>t.clone()),this}setAABB(){const t=this.body.transform,s=this.body.position,i=t.times(this.points[0]).add(s);this.aabb.min.x=this.aabb.max.x=i.x,this.aabb.min.y=this.aabb.max.y=i.y;for(let i=1;i<this.points.length;i++){const n=t.times(this.points[i]).add(s);n.x<this.aabb.min.x&&(this.aabb.min.x=n.x),n.y<this.aabb.min.y&&(this.aabb.min.y=n.y),n.x>this.aabb.max.x&&(this.aabb.max.x=n.x),n.y>this.aabb.max.y&&(this.aabb.max.y=n.y)}}raycast({p1:t,p2:s,maxFraction:i}){const n=this.body.transform.transpose();t=n.times(t.minus(this.body.position));const o=(s=n.times(s.minus(this.body.position))).minus(t);let e=0,r=i,h=-1;for(let s=0;s<this.points.length;s++){const i=this.norms[s].dot(this.points[s].minus(t)),n=this.norms[s].dot(o);if(0===n&&i<0)return null;if(n<0&&i<e*n?(e=i/n,h=s):n>0&&i<r*n&&(r=i/n),r<e)return null}return h>=0?{fraction:e,normal:n.times(this.norms[h])}:null}computeMass(t){const s=new MassData;let i=0,n=0;for(let t=0;t<this.points.length;t++){const o=t+1<this.points.length?t+1:0,e=this.points[t],r=this.points[o],h=e.cross(r),a=.5*h;i+=a,s.center.add(e.plus(r).mul(a*(1/3))),n+=1/3*.25*h*(e.x**2+r.x**2+e.x*r.x+(e.y**2+r.y**2+e.y*r.y))}return s.center.mul(1/i),s.m=t*i,s.iM=s.m?1/s.m:0,s.i=n*t,s.iI=s.i?1/s.i:0,s}getSupport(t){let s,i=-Number.MAX_VALUE;for(const n of this.points){const o=n.dot(t);o>i&&(i=o,s=n)}return s}recenter(t){for(const s of this.points)s.sub(t)}clone(){const s=Object.create(t.prototype);s.id=this.id,s.body=null,s.aabb=new AABB,s.points=[];for(const t of this.points)s.points.push(t.clone());s.norms=[];for(const t of this.norms)s.norms.push(t.clone());return s.originalPoints=this.originalPoints.map(t=>t.clone()),s}};"},"mass.js":{"/code":"const{Vector2D:Vector2D}=require(\"../framework/math\");module.exports=class{constructor(){this.m=0,this.iM=0,this.i=0,this.iI=0,this.center=new Vector2D(0,0)}};"},"circle.js":{"/code":"const{Vector2D:Vector2D}=require(\"../framework/math\"),MassData=require(\"./mass\"),{AABB:AABB,Shape:Shape}=require(\"./shape\");module.exports=class s extends Shape{constructor(s){super(),this.body=null,this.aabb=new AABB,this.radius=s}setAABB(){this.aabb.max.x=this.body.position.x+this.radius,this.aabb.max.y=this.body.position.y+this.radius,this.aabb.min.x=this.body.position.x-this.radius,this.aabb.min.y=this.body.position.y-this.radius}raycast({p1:s,p2:t,maxFraction:i}){const a=s.minus(this.body.position),r=a.dot(a)-this.radius**2,e=t.minus(s),o=a.dot(e),n=e.dot(e),u=o*o-n*r;if(u<0||n<Number.EPSILON)return null;let h=-(o+Math.sqrt(u));return h>=0&&h<=i*n?{fraction:h/=n,normal:a.plus(e.times(h)).normalize()}:null}computeMass(s){const t=new MassData;return t.center=new Vector2D(0,0),t.m=Math.PI*this.radius**2*s,t.iM=t.m?1/t.m:0,t.i=t.m*this.radius**2,t.iI=t.i?1/t.i:0,t}clone(){const t=Object.create(s.prototype);return t.id=this.id,t.body=null,t.aabb=new AABB,t.radius=this.radius,t}};"},"body.js":{"/code":"const{Vector2D:Vector2D,Rotation:Rotation,bigG:bigG}=require(\"../framework/math\"),MassData=require(\"./mass\");let next=0;module.exports=class{constructor({position:s=Vector2D.zero,angle:t,velocity:i=Vector2D.zero,angularVelocity:e,shapes:o,friction:r,restitution:n,density:a,sensor:h,static:c,filterGroup:l,exclusionList:m,onCollide:u}){this.id=next++,this.position=Vector2D.clone(s),this.prevPos=Vector2D.clone(s),this.transform=new Rotation(t||0),this.prevAngle=t||0,this.velocity=Vector2D.clone(i),this.angularVelocity=e||0,this.force=new Vector2D(0,0),this.torque=0,this.shapes=o,this.friction=null!=r?r:.6,this.restitution=null!=n?n:.2,a=null!=a?a:1,this.mass=new MassData;for(const s of this.shapes){s.body=this;const t=s.computeMass(a);this.mass.m+=t.m,this.mass.center.add(t.center.times(t.m)),this.mass.i+=t.i}this.mass.iM=this.mass.m?1/this.mass.m:0,this.mass.iI=this.mass.i?1/this.mass.i:0,this.mass.center.mul(this.mass.iM);for(const s of this.shapes)s.recenter instanceof Function&&s.recenter(this.mass.center),s.setAABB();this.position.add(this.mass.center),c&&this.setStatic(),this.sensor=h||!1,this.setFilter(null!=l?l:1,m||[]),this.onCollide=u}get originalPosition(){const s=this.transform.times(this.mass.center);return Object.freeze(this.position.minus(s))}get originalPrevPos(){const s=new Rotation(this.prevAngle).times(this.mass.center);return Object.freeze(this.prevPos.minus(s))}applyForce(s){this.force.add(s)}applyTorque(s){this.torque+=s}applyGravity(s,t,i){const e=bigG*s*this.mass.m/i**2,o=t.times(e);this.applyForce(o)}applyImpules(s,t){this.velocity.add(s.times(this.mass.iM)),this.angularVelocity+=this.mass.iI*t.cross(s)}setStatic(){this.mass.m=0,this.mass.iM=0,this.mass.i=0,this.mass.iI=0}setFilter(s,t){if(s>32||s<0)throw new Error(\"filter group is out of bounds (0 - 32)\");this.filterGroup=s?1<<s-1:0;let i=0;for(const s of t){if(s>32||s<2)throw new Error(\"exclusion group is out of bounds (2 - 32)\");i|=1<<s-1}this.exclusionMask=~i}};"}},"framework":{"math.js":{"/code":"function cleanAngle(t){return t-2*Math.PI*Math.trunc(t*i2pi+.5*Math.sign(t))}class Vector2D{constructor(t,i){this.x=t,this.y=i}set(t){return this.x=t.x,this.y=t.y,this}neg(){return new Vector2D(-this.x,-this.y)}negate(){return this.x=-this.x,this.y=-this.y,this}add(t){return this.x+=t.x,this.y+=t.y,this}sub(t){return this.x-=t.x,this.y-=t.y,this}mul(t){return this.x*=t,this.y*=t,this}plus(t){return new Vector2D(this.x+t.x,this.y+t.y)}minus(t){return new Vector2D(this.x-t.x,this.y-t.y)}times(t){return new Vector2D(this.x*t,this.y*t)}dot(t){return this.x*t.x+this.y*t.y}cross(t){return this.x*t.y-this.y*t.x}eq(t){return this.x===t.x&&this.y===t.y}get length(){return Math.sqrt(this.lsqr)}get lsqr(){return this.x**2+this.y**2}normalize(){const t=this.length;if(t<Number.EPSILON)return this;const i=1/t;return this.mul(i),this}clone(){return new Vector2D(this.x,this.y)}static clone(t){return new Vector2D(t.x,t.y)}static cross2x1(t,i){return new Vector2D(i*t.y,-i*t.x)}static cross1x2(t,i){return new Vector2D(-t*i.y,t*i.x)}static diff(t,i){return t.minus(i).length}static diffsqr(t,i){return t.minus(i).lsqr}}Vector2D.zero=new Vector2D(0,0);class Vector3D{constructor(t,i,s){this.x=t,this.y=i,this.z=s}set(t){return this.x=t.x,this.y=t.y,this.z=t.z,this}neg(){return new Vector3D(-this.x,-this.y,-this.z)}negate(){return this.x=-this.x,this.y=-this.y,this.z=-this.z,this}add(t){return this.x+=t.x,this.y+=t.y,this.z+=t.z,this}sub(t){return this.x-=t.x,this.y-=t.y,this.z-=t.z,this}plus(t){return new Vector3D(this.x+t.x,this.y+t.y,this.z+t.z)}minus(t){return new Vector3D(this.x-t.x,this.y-t.y,this.z-t.z)}dot(t){return this.x*t.x+this.y*t.y+this.z*t.z}cross(t){return new Vector3D(this.y*t.z-this.z*t.y,this.z*t.x-this.x*t.z,this.x*t.y-this.y*t.x)}clone(){return new Vector3D(this.x,this.y,this.z)}}class Matrix2D{constructor(t,i,s,r){this.ii=t,this.ij=i,this.ji=s,this.jj=r}set(t){return this.ii=t.ii,this.ij=t.ij,this.ji=t.ji,this.jj=t.jj,this}setRotation(t){const i=Math.cos(t),s=Math.sin(t);return this.ii=i,this.ij=-s,this.ji=s,this.jj=i,this}plus(t){return new Matrix2D(this.ii+t.ii,this.ij+t.ij,this.ji+t.ji,this.jj+t.jj)}times(t){return new Vector2D(this.ii*t.x+this.ij*t.y,this.ji*t.x+this.jj*t.y)}get determinant(){let t=this.ii*this.jj-this.ij*this.ji;return 0!==t&&(t=1/t),t}inverse(){const t=this.determinant;return new Matrix2D(t*this.jj,-t*this.ij,-t*this.ji,t*this.ii)}transpose(){return new Matrix2D(this.ii,this.ji,this.ij,this.jj)}solve(t){const i=this.determinant;return new Vector2D(i*(this.jj*t.x-this.ij*t.y),i*(this.ii*t.y-this.ji*t.x))}clone(){return new Matrix2D(this.ii,this.ij,this.ji,this.jj)}}Matrix2D.identity=new Matrix2D(1,0,0,1);class Rotation extends Matrix2D{constructor(t=0){super(),t=cleanAngle(t),this._r=t,this.setRotation(t)}set(t){return this.radians=t,this}get radians(){return this._r}set radians(t){t=cleanAngle(t),this.setRotation(t),this._r=t}clone(){return new Rotation(this.radians)}}class Matrix3D{constructor(t,i,s,r,e,h,n,o,c){this.m=[[t,i,s],[r,e,h],[n,o,c]]}solve2(t){const i=this.m;let s=i[0][0]*i[1][1]-i[0][1]*i[1][0];return 0!==s&&(s=1/s),new Vector2D(s*(i[1][1]*t.x-i[0][1]*t.y),s*(i[0][0]*t.y-i[1][0]*t.x))}solve3(t){const i=this.m,s=new Vector3D(i[0][0],i[1][0],i[2][0]),r=new Vector3D(i[0][1],i[1][1],i[2][1]),e=new Vector3D(i[0][2],i[1][2],i[2][2]);let h=s.dot(r.cross(e));return 0!==h&&(h=1/h),new Vector3D(h*t.dot(r.cross(e)),h*s.dot(t.cross(e)),h*s.dot(r.cross(t)))}clone(){return new Matrix3D(...this.m[0],...this.m[1],...this.m[2])}}const i2pi=1/(2*Math.PI);module.exports={Vector2D:Vector2D,Vector3D:Vector3D,Matrix2D:Matrix2D,Rotation:Rotation,Matrix3D:Matrix3D,cleanAngle:cleanAngle,bigG:6.674*Math.pow(10,-11),clamp:(t,i,s)=>Math.max(i,Math.min(t,s))};"},"solver.js":{"/code":"function solveBroadPhase(o){for(const s of o.bodies)for(const o of s.shapes)o.setAABB();o.broadPhase.updatePairs()}function solveNarrowPhase(o){for(const s of o.manifolds)s.solve()}function applyForces(o,s){for(const i of o.bodies)i.velocity.add(i.force.times(i.mass.iM).times(s)),i.angularVelocity+=i.torque*i.mass.iI*s}function solveVelocities(o,s){for(const s of o.manifolds)s.initialize();for(const s of o.manifolds)s.warmStart();for(const i of o.joints)i.initialize(s);for(let i=0;i<8;i++){for(const i of o.joints)i.applyImpulse(s);for(const s of o.manifolds)s.applyImpulse()}}function solvePositions(o,s){for(const i of o.bodies)i.prevPos=i.position.clone(),i.position.add(i.velocity.times(s)),i.prevAngle=i.transform.radians,i.transform.radians+=i.angularVelocity*s;for(let s=0;s<3;s++){for(const s of o.manifolds)s.positionalCorrection();for(const s of o.joints)s.positionalCorrection()}}function clearForces(o){for(const s of o.bodies)s.force.x=0,s.force.y=0,s.torque=0}function collisionCallbacks(o,s){for(const i of o.manifolds){const o=i.shapeA,t=i.shapeB;o.body.onCollide instanceof Function&&o.body.onCollide(new ContactData(i,!1,s)),t.body.onCollide instanceof Function&&t.body.onCollide(new ContactData(i,!0,s))}}const{BroadPhase:BroadPhase}=require(\"../collision/broadphase\"),ContactData=require(\"../collision/contactdata\"),{ManifoldMap:ManifoldMap}=require(\"../collision/manifold\");module.exports=class{constructor(){this.applyG=null,this.bodies=new Set,this.bodyMap={},this.joints=new Set,this.jointMap={},this.shapeMap={},this.manifolds=new ManifoldMap,this.broadPhase=new BroadPhase(this.manifolds)}solve(o){this.applyG&&this.applyG([...this.bodies]),solveBroadPhase(this),solveNarrowPhase(this),applyForces(this,o),solveVelocities(this,o),solvePositions(this,o),clearForces(this),collisionCallbacks(this,o)}addBody(o){this.bodies.add(o),this.bodyMap[o.id]=o;for(const s of o.shapes)this.broadPhase.insert(s),this.shapeMap[s.id]=s}removeBody(o){this.bodies.delete(o),delete this.bodyMap[o.id];for(const s of o.shapes)this.broadPhase.remove(s),delete this.shapeMap[s.id]}addJoint(o){this.joints.add(o),this.jointMap[o.id]=o}removeJoint(o){this.joints.delete(o),delete this.jointMap[o.id]}flush(){const o=[...this.bodies];return this.bodies.clear(),this.joints.clear(),this.manifolds.clear(),this.broadPhase.flush(),o}query(o,s){this.broadPhase.query(o,s)}raycast({p1:o,p2:s,callback:i,shouldCheck:t=null}){const e={p1:o,p2:s,maxFraction:1};this.broadPhase.raycast(e,(o,s)=>{if(t instanceof Function&&!t(s))return-1;const e=s.raycast(o);if(e){e.shape=s;const o=i(e);return null!=o?o:e.fraction}return-1})}debugGetNodes(){return this.broadPhase.debugGetNodes()}};"},"fork.js":{"/code":"function cloneMass(o){const n=new MassData;return n.m=o.m,n.iM=o.iM,n.i=o.i,n.iI=o.iI,n.center=o.center.clone(),n}function cloneBody(o,n){const e=Object.create(Body.prototype);return e.id=o.id,e.position=o.position.clone(),e.prevPos=o.prevPos.clone(),e.transform=o.transform.clone(),e.prevAngle=o.prevAngle,e.velocity=o.velocity.clone(),e.angularVelocity=o.angularVelocity,e.force=o.force.clone(),e.torque=o.torque,e.shapes=[],o.shapes.forEach(o=>{const a=o.clone();a.body=e,a.setAABB(),n[o.id]=a,e.shapes.push(a)}),e.friction=o.friction,e.restitution=o.restitution,e.mass=cloneMass(o.mass),e.sensor=o.sensor,e.filterGroup=o.filterGroup,e.exclusionMask=o.exclusionMask,e.onCollide=o.onCollide,e}function cloneJoint(o,n){return o.clone(n[o.bodyA.id],n[o.bodyB.id])}function cloneManifoldPoint(o){const n=new ManifoldPoint(o.point.clone(),o.lpoint.clone(),o.indexA,o.indexB,o.typeA,o.typeB);return n.bias=o.bias,n.normalImpulse=o.normalImpulse,n.tangentImpulse=o.tangentImpulse,n.normalMass=o.normalMass,n.tangentMass=o.tangentMass,n}function cloneManifold(o,n,e,a){const t=new Manifold(n,e,a);return t.type=o.type,o.contacts.forEach(o=>t.contacts.push(cloneManifoldPoint(o))),t.normal=o.normal.clone(),t.tangent=o.tangent.clone(),t.lpoint=o.lpoint.clone(),t.lnormal=o.lnormal.clone(),t.ltangent=o.ltangent.clone(),t.k=o.k.clone(),t.nMass=o.nMass?o.nMass.clone():null,t.hasSensor=o.hasSensor,t}function cloneManifoldMap(o,n){const e=new ManifoldMap;for(const[a,t]of o.map){const o=n[t.shapeA.id],s=n[t.shapeB.id];e.map.set(a,cloneManifold(t,o,s,a))}return e}function cloneNode(o,n,e,a){const t=Object.create(Node.prototype);return t.aabb=n.aabb.clone(),t.parent=o,t.children=[],n.children.forEach(o=>{t.children.push(cloneNode(t,o,e,a))}),t.height=n.height,null!=n.shape?(t.shape=e[n.shape.id],a[t.shape.id]=t):t.shape=null,t}function cloneAABBTree(o,n,e){const a=new AABBTree;return a.count=o.count,0===a.count?a:(a.root=cloneNode(null,o.root,n,e),a)}function cloneBroadPhase(o,n,e){const a=new BroadPhase(n);return a.tree=cloneAABBTree(o.tree,e,a.shapeToNode),a}const{Node:Node,AABBTree:AABBTree,BroadPhase:BroadPhase}=require(\"../collision/broadphase\"),{ManifoldPoint:ManifoldPoint,Manifold:Manifold,ManifoldMap:ManifoldMap}=require(\"../collision/manifold\"),Solver=require(\"./solver\"),Body=require(\"../objects/body\"),MassData=require(\"../objects/mass\");module.exports=function(o){const n=Object.create(Solver.prototype);return n.applyG=o.applyG,n.bodies=new Set,n.bodyMap={},n.joints=new Set,n.jointMap={},n.shapeMap={},o.bodies.forEach(o=>{const e=cloneBody(o,n.shapeMap);n.bodyMap[o.id]=e,n.bodies.add(e)}),o.joints.forEach(o=>{const e=cloneJoint(o,n.bodyMap);n.jointMap[o.id]=e,n.joints.add(e)}),n.manifolds=cloneManifoldMap(o.manifolds,n.shapeMap),n.broadPhase=cloneBroadPhase(o.broadPhase,n.manifolds,n.shapeMap),n};"}},"joints":{"wheeljoint.js":{"/code":"const{Vector2D:Vector2D,clamp:clamp}=require(\"../framework/math\"),Joint=require(\"./joint\");module.exports=class s extends Joint{constructor({bodyA:s,bodyB:t,anchorA:i,anchorB:o,axis:h,frequency:a,damping:m}){super({bodyA:s,bodyB:t,anchorA:i,anchorB:o}),this.axis=h.clone(),this.frequency=a,this.damping=m,this.motorOn=!1,this.motorSpeed=0,this.motorTorqueLimit=0,this.ax=new Vector2D(0,0),this.ay=new Vector2D(0,0),this.sAx=0,this.sAy=0,this.sBx=0,this.sBy=0,this.impulse=0,this.motorImpulse=0,this.springImpulse=0,this.mass=0,this.motorMass=0,this.springMass=0,this.bias=0,this.gamma=0}initialize(s){const t=this.bodyA.transform.times(this.anchorA),i=this.bodyB.transform.times(this.anchorB),o=this.bodyA.position,h=this.bodyB.position,a=this.bodyA.mass.iM,m=this.bodyB.mass.iM,r=this.bodyA.mass.iI,e=this.bodyB.mass.iI,n=h.plus(i).sub(o.plus(t));if(this.ay=this.bodyA.transform.times(Vector2D.cross1x2(1,this.axis)),this.sAy=n.plus(t).cross(this.ay),this.sBy=i.cross(this.ay),this.mass=a+m+r*this.sAy**2+e*this.sBy**2,this.mass>0&&(this.mass=1/this.mass),this.springMass=0,this.bias=0,this.gamma=0,this.frequency>0){this.ax=this.bodyA.transform.times(this.axis),this.sAx=n.plus(t).cross(this.ax),this.sBx=i.cross(this.ax);const o=a+m+r*this.sAx**2+e*this.sBx**2;if(o>0){this.springMass=1/o;const t=n.dot(this.ax),i=2*Math.PI*this.frequency,h=2*this.springMass*this.damping*i,a=this.springMass*i**2;this.gamma=s*(h+s*a),this.gamma>0&&(this.gamma=1/this.gamma),this.bias=t*s*a*this.gamma,this.springMass=o+this.gamma,this.springMass>0&&(this.springMass=1/this.springMass)}}else this.springImpulse=0;this.motorOn?(this.motorMass=r+e,this.motorMass>0&&(this.motorMass=1/this.motorMass)):(this.motorMass=0,this.motorImpulse=0);const y=this.ay.times(this.impulse).add(this.ax.times(this.springImpulse)),p=this.sAy*this.impulse+this.sAx*this.springImpulse+this.motorImpulse,l=this.sBy*this.impulse+this.sBx*this.springImpulse+this.motorImpulse;this.bodyA.velocity.sub(y.times(a)),this.bodyB.velocity.add(y.times(m)),this.bodyA.angularVelocity-=r*p,this.bodyB.angularVelocity+=e*l}applyImpulse(s){const t=this.bodyA.velocity,i=this.bodyB.velocity;let o=this.bodyA.angularVelocity,h=this.bodyB.angularVelocity;const a=this.bodyA.mass.iM,m=this.bodyB.mass.iM,r=this.bodyA.mass.iI,e=this.bodyB.mass.iI;{const s=-(this.ax.dot(i.minus(t))+this.sBx*h-this.sAx*o+this.bias+this.gamma*this.springImpulse)*this.springMass;this.springImpulse+=s;const n=this.ax.times(s),y=s*this.sAx,p=s*this.sBx;t.sub(n.times(a)),i.add(n.times(m)),o-=r*y,h+=e*p}{const t=h-o-this.motorSpeed;let i=-this.motorMass*t;const a=this.motorImpulse,m=s*this.motorTorqueLimit;this.motorImpulse=clamp(this.motorImpulse+i,-m,m),o-=r*(i=this.motorImpulse-a),h+=r*i}{const s=this.ay.dot(i.minus(t))+this.sBy*h-this.sAy*o,n=-this.mass*s;this.impulse+=n;const y=this.ay.times(n),p=n*this.sAy,l=n*this.sBy;t.sub(y.times(a)),i.add(y.times(m)),o-=r*p,h+=e*l}this.bodyA.velocity.set(t),this.bodyB.velocity.set(i),this.bodyA.angularVelocity=o,this.bodyB.angularVelocity=h}positionalCorrection(){const s=this.bodyA.transform.times(this.anchorA),t=this.bodyB.transform.times(this.anchorB),i=this.bodyA.position,o=this.bodyB.position,h=this.bodyA.mass.iM,a=this.bodyB.mass.iM,m=this.bodyA.mass.iI,r=this.bodyB.mass.iI,e=o.plus(t).sub(i.plus(s)),n=this.bodyA.transform.times(Vector2D.cross1x2(1,this.axis)),y=e.plus(s).cross(this.ay),p=t.cross(this.ay),l=e.dot(n),c=h+a+m*this.sAy**2+r*this.sBy**2;let d=0;0!==c&&(d=-l/c);const u=n.times(d),b=d*y,A=d*p;this.bodyA.position.sub(u.times(h)),this.bodyB.position.add(u.times(a)),this.bodyA.transform.radians-=m*b,this.bodyB.transform.radians+=r*A}setMotor(s,t=0){this.motorOn=null!=s,this.motorSpeed=s,this.motorTorqueLimit=t}clone(t,i){const o=Object.create(s.prototype);Joint.clone(o,this,t,i),o.axis=this.axis.clone(),o.frequency=this.frequency,o.damping=this.damping,o.motorOn=this.motorOn,o.motorSpeed=this.motorSpeed,o.motorTorqueLimit=this.motorTorqueLimit,o.ax=this.ax.clone(),o.ay=this.ay.clone(),o.sAx=this.sAx,o.sAy=this.sAy,o.sBx=this.sBx,o.sBy=this.sBy,o.impulse=this.impulse,o.motorImpulse=this.motorImpulse,o.springImpulse=this.springImpulse,o.mass=this.mass,o.motorMass=this.motorMass,o.springMass=this.springMass,o.bias=this.bias,o.gamma=this.gamma}};"},"joint.js":{"/code":"let next=0;module.exports=class{constructor({bodyA:o,bodyB:n,anchorA:c,anchorB:s}){this.id=next++,this.bodyA=o,this.bodyB=n,this.anchorA=c.minus(o.mass.center),this.anchorB=s.minus(n.mass.center)}static clone(o,n,c,s){o.id=n.id,o.bodyA=c,o.bodyB=s,o.anchorA=n.anchorA.clone(),o.anchorB=n.anchorB.clone()}};"},"springjoint.js":{"/code":"const{Vector2D:Vector2D,clamp:clamp}=require(\"../framework/math\"),Joint=require(\"./joint\");module.exports=class s extends Joint{constructor({bodyA:s,bodyB:t,anchorA:i,anchorB:o,length:h,frequency:a,damping:e}){super({bodyA:s,bodyB:t,anchorA:i,anchorB:o}),this.length=h,this.frequency=a,this.damping=e,this.u=new Vector2D(0,0),this.mass=0,this.impulse=0,this.gamma=0,this.bias=0}initialize(s){const t=this.bodyA.transform.times(this.anchorA),i=this.bodyB.transform.times(this.anchorB),o=this.bodyA.position,h=this.bodyB.position,a=this.bodyA.mass.iM,e=this.bodyB.mass.iM,m=this.bodyA.mass.iI,n=this.bodyB.mass.iI;this.u=h.plus(i).sub(o.plus(t));const r=this.u.length;r>.005?this.u.mul(1/r):(this.u.x=0,this.u.y=0);let c=a+m*t.cross(this.u)**2+e+n*i.cross(this.u)**2;if(this.mass=0!==c?1/c:0,this.frequency>0){const t=r-this.length,i=2*Math.PI*this.frequency,o=2*this.mass*this.damping*i,h=this.mass*i**2;this.gamma=s*(o+s*h),this.gamma=0!==this.gamma?1/this.gamma:0,this.bias=t*s*h*this.gamma,c+=this.gamma,this.mass=0!==c?1/c:0}else this.gamma=0,this.bias=0;const y=this.u.times(this.impulse);this.bodyA.velocity.sub(y.times(a)),this.bodyB.velocity.add(y.times(e)),this.bodyA.angularVelocity-=m*t.cross(y),this.bodyB.angularVelocity+=n*i.cross(y)}applyImpulse(){const s=this.bodyA.transform.times(this.anchorA),t=this.bodyB.transform.times(this.anchorB),i=this.bodyA.velocity,o=this.bodyB.velocity;let h=this.bodyA.angularVelocity,a=this.bodyB.angularVelocity;const e=this.bodyA.mass.iM,m=this.bodyB.mass.iM,n=this.bodyA.mass.iI,r=this.bodyB.mass.iI,c=i.plus(Vector2D.cross1x2(h,s)),y=o.plus(Vector2D.cross1x2(a,t)),d=this.u.dot(y.minus(c)),l=-this.mass*(d+this.bias+this.gamma*this.impulse);this.impulse+=l;const b=this.u.times(l);i.sub(b.times(e)),o.add(b.times(m)),h-=n*s.cross(b),a+=r*t.cross(b),this.bodyA.velocity.set(i),this.bodyB.velocity.set(o),this.bodyA.angularVelocity=h,this.bodyB.angularVelocity=a}positionalCorrection(){if(this.frequency>0)return;const s=this.bodyA.transform.times(this.anchorA),t=this.bodyB.transform.times(this.anchorB),i=this.bodyA.position,o=this.bodyB.position,h=this.bodyA.mass.iM,a=this.bodyB.mass.iM,e=this.bodyA.mass.iI,m=this.bodyB.mass.iI,n=o.plus(t).sub(i.plus(s)),r=n.length;n.mul(1/r);const c=clamp(r-this.length,-.2,.2),y=-this.mass*c,d=n.times(y);this.bodyA.position.sub(d.times(h)),this.bodyB.position.add(d.times(a)),this.bodyA.transform.radians-=e*s.cross(d),this.bodyB.transform.radians+=m*t.cross(d)}clone(t,i){const o=Object.create(s.prototype);Joint.clone(o,this,t,i),o.length=this.length,o.frequency=this.frequency,o.damping=this.damping,o.u=this.u.clone(),o.mass=this.mass,o.impulse=this.impulse,o.gamma=this.gamma,o.bias=this.bias}};"},"ropejoint.js":{"/code":"const{Vector2D:Vector2D,clamp:clamp}=require(\"../framework/math\"),Joint=require(\"./joint\");module.exports=class s extends Joint{constructor({bodyA:s,bodyB:i,anchorA:t,anchorB:o,limit:h}){super({bodyA:s,bodyB:i,anchorA:t,anchorB:o}),this.limit=h,this.u=new Vector2D(0,0),this.mass=0,this.impulse=0,this.distance=0}initialize(){const s=this.bodyA.transform.times(this.anchorA),i=this.bodyB.transform.times(this.anchorB),t=this.bodyA.position,o=this.bodyB.position,h=this.bodyA.mass.iM,e=this.bodyB.mass.iM,a=this.bodyA.mass.iI,n=this.bodyB.mass.iI;if(this.u=o.plus(i).sub(t.plus(s)),this.distance=this.u.length,this.distance<.005)return this.u.x=0,this.u.y=0,this.mass=0,void(this.impulse=0);this.u.mul(1/this.distance);const m=h+a*s.cross(this.u)**2+e+n*i.cross(this.u)**2;this.mass=0!==m?1/m:0;const c=this.u.times(this.impulse);this.bodyA.velocity.sub(c.times(h)),this.bodyB.velocity.add(c.times(e)),this.bodyA.angularVelocity-=a*s.cross(c),this.bodyB.angularVelocity+=n*i.cross(c)}applyImpulse(s){const i=this.bodyA.transform.times(this.anchorA),t=this.bodyB.transform.times(this.anchorB),o=this.bodyA.velocity,h=this.bodyB.velocity;let e=this.bodyA.angularVelocity,a=this.bodyB.angularVelocity;const n=this.bodyA.mass.iM,m=this.bodyB.mass.iM,c=this.bodyA.mass.iI,r=this.bodyB.mass.iI,d=o.plus(Vector2D.cross1x2(e,i)),l=h.plus(Vector2D.cross1x2(a,t)),y=this.distance-this.limit;let u=this.u.dot(l.minus(d));y<0&&(u+=1/s*y);let b=-this.mass*u;const p=this.impulse;this.impulse=Math.min(0,this.impulse+b),b=this.impulse-p;const A=this.u.times(b);o.sub(A.times(n)),h.add(A.times(m)),e-=c*i.cross(A),a+=r*t.cross(A),this.bodyA.velocity.set(o),this.bodyB.velocity.set(h),this.bodyA.angularVelocity=e,this.bodyB.angularVelocity=a}positionalCorrection(){const s=this.bodyA.transform.times(this.anchorA),i=this.bodyB.transform.times(this.anchorB),t=this.bodyA.position,o=this.bodyB.position,h=this.bodyA.mass.iM,e=this.bodyB.mass.iM,a=this.bodyA.mass.iI,n=this.bodyB.mass.iI,m=o.plus(i).sub(t.plus(s)),c=m.length;m.mul(1/c);const r=clamp(c-this.limit,0,.2),d=-this.mass*r,l=m.times(d);this.bodyA.position.sub(l.times(h)),this.bodyB.position.add(l.times(e)),this.bodyA.transform.radians-=a*s.cross(l),this.bodyB.transform.radians+=n*i.cross(l)}clone(i,t){const o=Object.create(s.prototype);return Joint.clone(o,this,i,t),o.limit=this.limit,o.u=this.u.clone(),o.mass=this.mass,o.impulse=this.impulse,o.distance=this.distance,o}};"},"revjoint.js":{"/code":"const{Vector2D:Vector2D,Vector3D:Vector3D,Matrix2D:Matrix2D,Matrix3D:Matrix3D,cleanAngle:cleanAngle,clamp:clamp}=require(\"../framework/math\"),Joint=require(\"./joint\");class RevJoint extends Joint{constructor({bodyA:t,bodyB:s,anchorA:i,anchorB:e,upperLimit:o,lowerLimit:a}){super({bodyA:t,bodyB:s,anchorA:i,anchorB:e}),this.mass=new Matrix3D(0,0,0,0,0,0,0,0,0),null!=o&&null!=a?this.setLimit(!0,o,a):this.setLimit(!1),this.refAngle=cleanAngle(s.transform.radians-t.transform.radians),this.cumulativeImpulse=new Vector3D(0,0,0),this.state=-1}initialize(){const t=this.bodyA.transform.times(this.anchorA),s=this.bodyB.transform.times(this.anchorB),i=this.bodyA.mass.iM,e=this.bodyB.mass.iM,o=this.bodyA.mass.iI,a=this.bodyB.mass.iI;if(this.mass.m[0][0]=i+e+t.y**2*o+s.y**2*a,this.mass.m[0][1]=-t.y*t.x*o-s.y*s.x*a,this.mass.m[0][2]=-t.y*o-s.y*a,this.mass.m[1][0]=this.mass.m[0][1],this.mass.m[1][1]=i+e+t.x**2*o+s.x**2*a,this.mass.m[1][2]=t.x*o+s.x*a,this.mass.m[2][0]=this.mass.m[0][2],this.mass.m[2][1]=this.mass.m[1][2],this.mass.m[2][2]=o+a,this.limitEnabled){let t=this.bodyB.transform.radians-this.bodyA.transform.radians;(t=cleanAngle(t-this.refAngle))<=this.lowerLimit?(this.state!==RevJoint.atLower&&(this.cumulativeImpulse.z=0),this.state=RevJoint.atLower):t>=this.upperLimit?(this.state!==RevJoint.atUpper&&(this.cumulativeImpulse.z=0),this.state=RevJoint.atUpper):(this.state=RevJoint.between,this.cumulativeImpulse.z=0)}const m=new Vector2D(this.cumulativeImpulse.x,this.cumulativeImpulse.y);this.bodyA.velocity.sub(m.times(i)),this.bodyB.velocity.add(m.times(e)),this.bodyA.angularVelocity-=o*(t.cross(m)+this.cumulativeImpulse.z),this.bodyB.angularVelocity+=a*(s.cross(m)+this.cumulativeImpulse.z)}applyImpulse(){const t=this.bodyA.transform.times(this.anchorA),s=this.bodyB.transform.times(this.anchorB),i=this.bodyA.velocity,e=this.bodyB.velocity;let o=this.bodyA.angularVelocity,a=this.bodyB.angularVelocity;const m=this.bodyA.mass.iM,l=this.bodyB.mass.iM,h=this.bodyA.mass.iI,r=this.bodyB.mass.iI;if(this.limitEnabled&&this.state!==RevJoint.between){const n=e.plus(Vector2D.cross1x2(a,s)).sub(i.plus(Vector2D.cross1x2(o,t))),u=a-o,c=new Vector3D(n.x,n.y,u),y=this.mass.solve3(c).negate();if(this.state===RevJoint.atLower)if(this.cumulativeImpulse.z+y.z<0){const t=n.negate().add({x:this.mass.m[0][2],y:this.mass.m[1][2]}).mul(this.cumulativeImpulse.z),s=this.mass.solve2(t);y.set(s),y.z=-this.cumulativeImpulse.z,this.cumulativeImpulse.x+=s.x,this.cumulativeImpulse.y+=s.y,this.cumulativeImpulse.z=0}else this.cumulativeImpulse.add(y);else if(this.cumulativeImpulse.z+y.z>0){const t=n.negate().add({x:this.mass.m[0][2],y:this.mass.m[1][2]}).mul(this.cumulativeImpulse.z),s=this.mass.solve2(t);y.set(s),y.z=-this.cumulativeImpulse.z,this.cumulativeImpulse.x+=s.x,this.cumulativeImpulse.y+=s.y,this.cumulativeImpulse.z=0}else this.cumulativeImpulse.add(y);const d=new Vector2D(y.x,y.y);i.sub(d.times(m)),e.add(d.times(l)),o-=h*(t.cross(d)+y.z),a+=r*(s.cross(d)+y.z)}else{const n=e.plus(Vector2D.cross1x2(a,s)).sub(i.plus(Vector2D.cross1x2(o,t))),u=this.mass.solve2(n.negate());this.cumulativeImpulse.x+=u.x,this.cumulativeImpulse.y+=u.y,i.sub(u.times(m)),e.add(u.times(l)),o-=h*t.cross(u),a+=r*s.cross(u)}this.bodyA.velocity.set(i),this.bodyB.velocity.set(e),this.bodyA.angularVelocity=o,this.bodyB.angularVelocity=a}positionalCorrection(){const t=this.bodyA.transform.times(this.anchorA),s=this.bodyB.transform.times(this.anchorB),i=this.bodyA.position,e=this.bodyB.position;let o=this.bodyA.transform.radians,a=this.bodyB.transform.radians;const m=this.bodyA.mass.iM,l=this.bodyB.mass.iM,h=this.bodyA.mass.iI,r=this.bodyB.mass.iI;if(this.limitEnabled&&this.state!==RevJoint.between){const t=cleanAngle(a-o-this.refAngle);let s=0;if(this.state===RevJoint.atLower){let i=t-this.lowerLimit;s=-1/(h+r)*(i=clamp(i+1/90*Math.PI,-1/22.5*Math.PI,0))}else{let i=t-this.upperLimit;s=-1/(h+r)*(i=clamp(i-1/90*Math.PI,0,1/22.5*Math.PI))}o-=h*s,a+=r*s}const n=e.plus(s).sub(i.plus(t)),u=new Matrix2D(m+l+h*t.y*t.y+r*s.y*s.y,-h*t.x*t.y-r*s.x*s.y,-h*t.x*t.y-r*s.x*s.y,m+l+h*t.x*t.x+r*s.x*s.x).solve(n).negate();i.sub(u.times(m)),e.add(u.times(l)),o-=h*t.cross(u),a+=r*s.cross(u),this.bodyA.position=i,this.bodyB.position=e,this.bodyA.transform.radians=o,this.bodyB.transform.radians=a}setLimit(t,s,i){if(!t)return this.limitEnabled=!1,this.upperLimit=null,void(this.lowerLimit=null);if(s>Math.PI||s<-Math.PI)throw new Error(\"upper limit out of bounts (-pi to pi)\");if(i>Math.PI||i<-Math.PI)throw new Error(\"lower limit out of bounts (-pi to pi)\");if(i>s)throw new Error(\"upper limit must be greater than lower limit\");this.limitEnabled=t,this.upperLimit=s,this.lowerLimit=i}clone(t,s){const i=Object.create(RevJoint.prototype);return Joint.clone(i,this,t,s),i.mass=this.mass.clone(),i.limitEnabled=this.limitEnabled,i.upperLimit=this.upperLimit,i.lowerLimit=this.lowerLimit,i.refAngle=this.refAngle,i.cumulativeImpulse=this.cumulativeImpulse.clone(),i.state=this.state,i}}RevJoint.atUpper=0,RevJoint.atLower=1,RevJoint.between=2,module.exports=RevJoint;"}},"collision":{"manifold.js":{"/code":"const{Vector2D:Vector2D,Matrix2D:Matrix2D,clamp:clamp}=require(\"../framework/math\");class ManifoldPoint{constructor(s,t,i,o,a,e){this.point=s||new Vector2D(0,0),this.lpoint=t||new Vector2D(0,0),this.bias=0,this.normalImpulse=0,this.tangentImpulse=0,this.normalMass=0,this.tangentMass=0,this.indexA=i,this.indexB=o,this.typeA=a,this.typeB=e}equals(s){return null!=this.indexA&&this.indexA===s.indexA&&this.indexB===s.indexB&&this.typeA===s.typeA&&this.typeB===s.typeB}flip(){[this.indexA,this.indexB]=[this.indexB,this.indexA],[this.typeA,this.typeB]=[this.typeB,this.typeA]}absorb(s){this.normalImpulse=s.normalImpulse,this.tangentImpulse=s.tangentImpulse}}ManifoldPoint.face=0,ManifoldPoint.vert=1;class Manifold{constructor(s,t,i){this.shapeA=s,this.shapeB=t,this.key=i,this.type=-1,this.e=Math.max(s.body.restitution,t.body.restitution),this.df=Math.sqrt(s.body.friction,t.body.friction),this.contacts=[],this.normal=new Vector2D(0,0),this.tangent=new Vector2D(0,0),this.lpoint=new Vector2D(0,0),this.lnormal=new Vector2D(0,0),this.ltangent=new Vector2D(0,0),this.k=new Matrix2D(0,0,0,0),this.nMass=null,this.hasSensor=s.body.sensor||t.body.sensor}solve(){const s=this.shapeA,t=this.shapeB;s.aabb.test(t.aabb)?Collision.getCollider(s.constructor,t.constructor)(this,s,t):this.contacts=[]}get isCollided(){return!this.hasSensor&&this.contacts.length>0}initialize(){if(!this.isCollided)return;const s=this.shapeA.body.mass.iM,t=this.shapeA.body.mass.iI,i=this.shapeB.body.mass.iM,o=this.shapeB.body.mass.iI,a=this.shapeA.body.velocity,e=this.shapeB.body.velocity,n=this.shapeA.body.angularVelocity,h=this.shapeB.body.angularVelocity;for(const l of this.contacts){const r=l.point.minus(this.shapeA.body.position),p=l.point.minus(this.shapeB.body.position),c=r.cross(this.normal),m=p.cross(this.normal),d=s+i+c*c*t+m*m*o;l.normalMass=d>0?1/d:0;const y=r.cross(this.tangent),u=p.cross(this.tangent),b=s+i+y*y*t+u*u*o;l.tangentMass=b>0?1/b:0,l.bias=0;const f=e.plus(Vector2D.cross1x2(h,p)).sub(a.plus(Vector2D.cross1x2(n,r))),A=this.normal.dot(f);A<-1&&(l.bias=-this.e*A)}if(2===this.contacts.length){const a=this.contacts[0].point.minus(this.shapeA.body.position),e=this.contacts[0].point.minus(this.shapeB.body.position),n=this.contacts[1].point.minus(this.shapeA.body.position),h=this.contacts[1].point.minus(this.shapeB.body.position),l=a.cross(this.normal),r=e.cross(this.normal),p=n.cross(this.normal),c=h.cross(this.normal),m=s+i+t*l*l+o*r*r,d=s+i+t*p*p+o*c*c,y=s+i+t*l*p+o*r*c;m*m<1e3*(m*d-y*y)?(this.k.ii=m,this.k.ij=y,this.k.ji=y,this.k.jj=d,this.nMass=this.k.inverse()):this.contacts.pop()}}warmStart(){if(!this.isCollided)return;const s=this.shapeA.body.mass.iM,t=this.shapeA.body.mass.iI,i=this.shapeB.body.mass.iM,o=this.shapeB.body.mass.iI,a=this.shapeA.body.velocity,e=this.shapeB.body.velocity;let n=this.shapeA.body.angularVelocity,h=this.shapeB.body.angularVelocity;for(const l of this.contacts){const r=l.point.minus(this.shapeA.body.position),p=l.point.minus(this.shapeB.body.position),c=this.normal.times(l.normalImpulse).add(this.tangent.times(l.tangentImpulse));a.sub(c.times(s)),e.add(c.times(i)),n-=t*r.cross(c),h+=o*p.cross(c)}this.shapeA.body.velocity.set(a),this.shapeB.body.velocity.set(e),this.shapeA.body.angularVelocity=n,this.shapeB.body.angularVelocity=h}applyImpulse(){if(!this.isCollided)return;const s=this.shapeA.body.mass.iM,t=this.shapeA.body.mass.iI,i=this.shapeB.body.mass.iM,o=this.shapeB.body.mass.iI,a=this.shapeA.body.velocity,e=this.shapeB.body.velocity;let n=this.shapeA.body.angularVelocity,h=this.shapeB.body.angularVelocity;for(const l of this.contacts){const r=l.point.minus(this.shapeA.body.position),p=l.point.minus(this.shapeB.body.position),c=e.plus(Vector2D.cross1x2(h,p)).sub(a.plus(Vector2D.cross1x2(n,r))).dot(this.tangent);let m=l.tangentMass*-c;const d=l.normalImpulse*this.df,y=clamp(l.tangentImpulse+m,-d,d);m=y-l.tangentImpulse,l.tangentImpulse=y;const u=this.tangent.times(m);a.sub(u.times(s)),e.add(u.times(i)),n-=t*r.cross(u),h+=o*p.cross(u)}if(1===this.contacts.length){const l=this.contacts[0],r=l.point.minus(this.shapeA.body.position),p=l.point.minus(this.shapeB.body.position),c=e.plus(Vector2D.cross1x2(h,p)).sub(a.plus(Vector2D.cross1x2(n,r))).dot(this.normal);let m=-l.normalMass*(c-l.bias);const d=Math.max(l.normalImpulse+m,0);m=d-l.normalImpulse,l.normalImpulse=d;const y=this.normal.times(m);a.sub(y.times(s)),e.add(y.times(i)),n-=t*r.cross(y),h+=o*p.cross(y)}else{const l=this.contacts[0],r=this.contacts[1],p=l.point.minus(this.shapeA.body.position),c=l.point.minus(this.shapeB.body.position),m=r.point.minus(this.shapeA.body.position),d=r.point.minus(this.shapeB.body.position),y=new Vector2D(l.normalImpulse,r.normalImpulse),u=e.plus(Vector2D.cross1x2(h,c)).sub(a.plus(Vector2D.cross1x2(n,p))),b=e.plus(Vector2D.cross1x2(h,d)).sub(a.plus(Vector2D.cross1x2(n,m)));let f=u.dot(this.normal),A=b.dot(this.normal);const B=new Vector2D(f-l.bias,A-r.bias).sub(this.k.times(y));for(;;){const u=this.nMass.times(B).negate();if(u.x>=0&&u.y>=0){const b=u.minus(y),f=this.normal.times(b.x),A=this.normal.times(b.y);a.sub(f.plus(A).mul(s)),e.add(f.plus(A).mul(i)),n-=t*(p.cross(f)+m.cross(A)),h+=o*(c.cross(f)+d.cross(A)),l.normalImpulse=u.x,r.normalImpulse=u.y;break}if(u.x=-l.normalMass*B.x,u.y=0,f=0,A=this.k.ji*u.x+B.yy,u.x>=0&&u.y>=0){const b=u.minus(y),f=this.normal.times(b.x),A=this.normal.times(b.y);a.sub(f.plus(A).mul(s)),e.add(f.plus(A).mul(i)),n-=t*(p.cross(f)+m.cross(A)),h+=o*(c.cross(f)+d.cross(A)),l.normalImpulse=u.x,r.normalImpulse=u.y;break}if(u.x=0,u.y=-r.normalMass*B.y,f=this.k.ij*u.y+B.x,A=0,u.y>=0&&f>=0){const b=u.minus(y),f=this.normal.times(b.x),A=this.normal.times(b.y);a.sub(f.plus(A).mul(s)),e.add(f.plus(A).mul(i)),n-=t*(p.cross(f)+m.cross(A)),h+=o*(c.cross(f)+d.cross(A)),l.normalImpulse=u.x,r.normalImpulse=u.y;break}if(u.x=0,u.y=0,f=B.x,A=B.y,f>=0&&A>=0){const b=u.minus(y),f=this.normal.times(b.x),A=this.normal.times(b.y);a.sub(f.plus(A).mul(s)),e.add(f.plus(A).mul(i)),n-=t*(p.cross(f)+m.cross(A)),h+=o*(c.cross(f)+d.cross(A)),l.normalImpulse=u.x,r.normalImpulse=u.y;break}break}}this.shapeA.body.velocity.set(a),this.shapeB.body.velocity.set(e),this.shapeA.body.angularVelocity=n,this.shapeB.body.angularVelocity=h}positionalCorrection(){if(!this.isCollided)return;const s=this.shapeA.body.mass.iM,t=this.shapeA.body.mass.iI,i=this.shapeB.body.mass.iM,o=this.shapeB.body.mass.iI,a=this.shapeA.body.position.clone(),e=this.shapeB.body.position.clone();let n=this.shapeA.body.transform.radians,h=this.shapeB.body.transform.radians,l=0;l+=this.shapeA.radius?this.shapeA.radius:0,l+=this.shapeB.radius?this.shapeB.radius:0;for(const r of this.contacts){let p,c,m;if(this.type===Manifold.circles){const s=this.lpoint.plus(this.shapeA.body.position),t=this.contacts[0].lpoint.plus(this.shapeB.body.position);m=t.minus(s).normalize(),p=s.plus(t).mul(.5),c=t.minus(s).dot(m)-l}else if(this.type===Manifold.faceA){m=this.shapeA.body.transform.times(this.lnormal);const s=this.shapeA.body.transform.times(this.lpoint).add(this.shapeA.body.position),t=this.shapeB.body.transform.times(r.lpoint).add(this.shapeB.body.position);c=t.minus(s).dot(m)-l,p=t}else if(this.type===Manifold.faceB){m=this.shapeB.body.transform.times(this.lnormal);const s=this.shapeB.body.transform.times(this.lpoint).add(this.shapeB.body.position),t=this.shapeA.body.transform.times(r.lpoint).add(this.shapeA.body.position);c=t.minus(s).dot(m)-l,p=t,m.negate()}const d=p.minus(this.shapeA.body.position),y=p.minus(this.shapeB.body.position),u=clamp(.2*(c+.005),-.2,0),b=d.cross(m),f=y.cross(m),A=s+i+t*b*b+o*f*f,B=A>0?-u/A:0,M=m.times(B);a.sub(M.times(s)),e.add(M.times(i)),n-=t*d.cross(M),h+=o*y.cross(M)}this.shapeA.body.position.set(a),this.shapeB.body.position.set(e),this.shapeA.body.transform.radians=n,this.shapeB.body.transform.radians=h}}Manifold.circles=0,Manifold.faceA=1,Manifold.faceB=2;class ManifoldMap{constructor(){this.map=new Map}add({a:s,b:t}){const i=`${s.id}:${t.id}`;this.map.has(i)||this.map.set(i,new Manifold(s,t,i))}delete(s){this.map.delete(s)}clear(){this.map.clear()}keys(){return this.map.keys()}[Symbol.iterator](){return this.map.values()}}module.exports={ManifoldPoint:ManifoldPoint,Manifold:Manifold,ManifoldMap:ManifoldMap};const Collision=require(\"./collision.js\");"},"collision.js":{"/code":"function findSeparatingAxis(o,n){const t=n.body.transform.transpose();let i=-Number.MAX_VALUE,e=0;for(let s=0;s<o.points.length;s++){const l=o.body.transform.times(o.norms[s]),r=t.times(l),a=n.getSupport(r.neg());let d=o.body.transform.times(o.points[s]).add(o.body.position);d=t.times(d.minus(n.body.position));const c=r.dot(a.minus(d));c>i&&(i=c,e=s)}return{index:e,distance:i}}function findIncidentEdge(o,n,t){let i=o.norms[t];i=o.body.transform.times(i),i=n.body.transform.transpose().times(i);let e=0,s=Number.MAX_VALUE;for(let o=0;o<n.points.length;o++){const t=i.dot(n.norms[o]);t<s&&(s=t,e=o)}const l=e+1>=n.points.length?0:e+1;return[new ManifoldPoint(n.body.transform.times(n.points[e]).add(n.body.position),n.points[e],t,e,ManifoldPoint.face,ManifoldPoint.vert),new ManifoldPoint(n.body.transform.times(n.points[l]).add(n.body.position),n.points[l],t,l,ManifoldPoint.face,ManifoldPoint.vert)]}function clipPoints(o,n,t,i){const e=[],s=n.dot(o[0].point)-t,l=n.dot(o[1].point)-t;if(s<=0&&e.push(o[0]),l<=0&&e.push(o[1]),s*l<0){const n=s/(s-l);e.push(new ManifoldPoint(o[0].point.plus(o[1].point.minus(o[0].point).mul(n)),o[0].lpoint.plus(o[1].lpoint.minus(o[0].lpoint).mul(n)),i,o[0].indexB,ManifoldPoint.vert,ManifoldPoint.face))}return e}function polyToPoly(o,n,t){const i=o.contacts;o.contacts=[];const{index:e,distance:s}=findSeparatingAxis(n,t);if(s>0)return;const{index:l,distance:r}=findSeparatingAxis(t,n);if(r>0)return;let a,d,c,m;r>s+5e-4?(c=t,m=n,a=l,o.type=Manifold.faceB,d=!0):(c=n,m=t,a=e,o.type=Manifold.faceA,d=!1);const p=findIncidentEdge(c,m,a),f=a,u=f+1>=c.points.length?0:f+1;let y=c.points[f],b=c.points[u];o.ltangent=b.minus(y).normalize(),o.lnormal=Vector2D.cross2x1(o.ltangent,1),o.lpoint=y.plus(b).mul(.5);const g=c.body.transform.times(o.ltangent),M=Vector2D.cross2x1(g,1);y=c.body.transform.times(y).add(c.body.position),b=c.body.transform.times(b).add(c.body.position);const P=M.dot(y),h=-g.dot(y),C=g.dot(b);let w=clipPoints(p,g.neg(),h,f);if(!(w.length<2||(w=clipPoints(w,g,C,u)).count<2)){for(const n of w)if(M.dot(n.point)-P<=0){d&&n.flip();for(const o of i)n.equals(o)&&n.absorb(o);o.contacts.push(n)}o.normal=d?M.negate():M,o.tangent=d?g.negate():g}}function circleToCircle(o,n,t){o.contacts=[],o.normal=t.body.position.minus(n.body.position),o.normal.lsqr>(n.radius+t.radius)**2||(o.contacts.push(new ManifoldPoint(t.body.position.plus(n.body.position).mul(.5))),o.type=Manifold.circles,o.normal.normalize(),o.tangent=Vector2D.cross2x1(o.normal,1))}function circleToPoly(o,n,t){o.contacts=[];const i=t.body.transform.transpose().times(n.body.position.minus(t.body.position));let e=-Number.MAX_VALUE,s=0;for(let o=0;o<t.points.length;o++){const l=t.norms[o].dot(i.minus(t.points[o]));if(l>n.radius)return;l>e&&(e=l,s=o)}const l=s+1<t.points.length?s+1:0,r=t.points[s],a=t.points[l];if(e<Number.EPSILON)o.type=Manifold.faceB,o.lnormal=t.norms[s],o.lpoint=r.plus(a).mul(.5),o.normal=t.body.transform.times(t.norms[s]).negate(),o.contacts.push(new ManifoldPoint(o.normal.times(n.radius).add(n.body.position)));else{const e=i.minus(r).dot(a.minus(r)),l=i.minus(a).dot(r.minus(a));if(e<=0){if(i.minus(r).lsqr>n.radius**2)return;o.type=Manifold.faceB,o.lnormal=i.minus(r).normalize(),o.normal=t.body.transform.times(o.lnormal).negate().normalize(),o.lpoint=r,o.contacts.push(new ManifoldPoint(t.body.transform.times(r).add(t.body.position)))}else if(l<=0){if(i.minus(a).lsqr>n.radius**2)return;o.type=Manifold.faceB,o.lnormal=i.minus(a).normalize(),o.normal=t.body.transform.times(o.lnormal).negate().normalize(),o.lpoint=a,o.contacts.push(new ManifoldPoint(t.body.transform.times(a).add(t.body.position)))}else{if(o.lpoint=r.plus(a).mul(.5),o.lnormal=t.norms[s],i.minus(o.lpoint).dot(o.lnormal)>n.radius)return;o.normal=t.body.transform.times(o.lnormal).negate().normalize(),o.type=Manifold.faceB,o.contacts.push(new ManifoldPoint(o.normal.times(n.radius).add(n.body.position)))}}o.tangent=Vector2D.cross2x1(o.normal,1)}function polyToCircle(o,n,t){circleToPoly(o,t,n),o.type=Manifold.faceA,o.normal.negate(),o.tangent.negate()}const{Vector2D:Vector2D}=require(\"../framework/math\"),{Manifold:Manifold,ManifoldPoint:ManifoldPoint}=require(\"./manifold\"),Polygon=require(\"../objects/polygon\"),Circle=require(\"../objects/circle\"),baseMap=new Map;class Collision{static getCollider(o,n){if(!baseMap.has(o))throw{message:\"collider not set for type combination\",type1:o,type2:n};if(!baseMap.get(o).has(n))throw{message:\"collider not set for type combination\",type1:o,type2:n};return baseMap.get(o).get(n)}static newCollider(o,n,t){baseMap.has(o)||baseMap.set(o,new Map),baseMap.get(o).set(n,t)}}module.exports=Collision,Collision.newCollider(Polygon,Polygon,polyToPoly),Collision.newCollider(Circle,Circle,circleToCircle),Collision.newCollider(Circle,Polygon,circleToPoly),Collision.newCollider(Polygon,Circle,polyToCircle);"},"contactdata.js":{"/code":"module.exports=class{constructor(s,e,t){if(this.shape=e?s.shapeB:s.shapeA,this.otherShape=e?s.shapeA:s.shapeB,this.normalForces=[],this.tangentForces=[],!s.hasSensor)for(const a of s.contacts){const n=s.normal.times(a.normalImpulse/t),o=s.tangent.times(a.tangentImpulse/t);e&&(n.negate(),o.negate()),this.normalForces.push(n),this.tangentForces.push(o)}}};"},"broadphase.js":{"/code":"function makeFatAABB(e){return new AABB(e.min.x-.2,e.min.y-.2,e.max.x+.2,e.max.y+.2)}const{Vector2D:Vector2D}=require(\"../framework/math\"),{AABB:AABB,Shape:Shape}=require(\"../objects/shape\");class Node{constructor(e,a=null,t=0){this.aabb=makeFatAABB(e),this.parent=a,this.children=[],this.height=t,this.shape=null}get isLeaf(){return 0===this.children.length}}class AABBTree{constructor(){this.count=0,this.root=null}insert(e){const a=new Node(e);return this.insertLeaf(a),a}remove(e){this.removeLeaf(e)}clear(){this.count=0,this.root=null}checkMove(e,a,t){if(e.aabb.contains(a))return!1;e.aabb=makeFatAABB(a);const h=t.times(2);return(h.x<0?e.aabb.min:e.aabb.max).x+=h.x,(h.y<0?e.aabb.min:e.aabb.max).y+=h.y,this.removeLeaf(e),this.insertLeaf(e),!0}query(e,a){const t=[this.root];for(;t.length>0;){const h=t.pop();if(null!=h&&h.aabb.test(e.aabb)){if(h.isLeaf&&!a(e,h))return;t.push(h.children[0],h.children[1])}}}rayCast({p1:e,p2:a,maxFraction:t},h){const i=a.minus(e).normalize(),r=Vector2D.cross1x2(1,i),n=new Vector2D(Math.abs(r.x),Math.abs(r.y));let s=e.plus(a.minus(e).mul(t)),o=new AABB(Math.min(e.x,s.x),Math.min(e.y,s.y),Math.max(e.x,s.x),Math.max(e.y,s.y));const b=[this.root];for(;b.length>0;){const i=b.pop();if(null==i||!i.aabb.test(o))continue;const c=i.aabb.min.plus(i.aabb.max).mul(.5),l=i.aabb.max.minus(i.aabb.min).mul(.5);if(!(Math.abs(r.dot(e.minus(c)))-n.dot(l)>0))if(i.isLeaf){const r=h({p1:e,p2:a,maxFraction:t},i);if(0===r)return;r>0&&(t=r,s=e.plus(a.minus(e).mul(t)),o=new AABB(Math.min(e.x,s.x),Math.min(e.y,s.y),Math.max(e.x,s.x),Math.max(e.y,s.y)))}else b.push(i.children[0],i.children[1])}}insertLeaf(e){if(this.count++,null===this.root)return this.root=e,void(this.root.parent=null);let a=this.root;for(;!a.isLeaf;){const t=a.aabb.perimeter,h=e.aabb.combine(a.aabb).perimeter,i=2*h,r=2*(h-t);let n;if(a.children[0].isLeaf)n=e.aabb.combine(a.children[0].aabb).perimeter+r;else{const t=a.children[0].aabb.perimeter;n=e.aabb.combine(a.children[0].aabb).perimeter-t+r}let s;if(a.children[1].isLeaf)s=e.aabb.combine(a.children[1].aabb).perimeter+r;else{const t=a.children[1].aabb.perimeter;s=e.aabb.combine(a.children[1].aabb).perimeter-t+r}if(i<n&&i<s)break;a=n<s?a.children[0]:a.children[1]}const t=a.parent,h=new Node(e.aabb.combine(a.aabb),t,a.height+1);for(null!=t?(t.children[0]===a?t.children[0]=h:t.children[1]=h,h.children.push(a,e),a.parent=h,e.parent=h):(h.children.push(a,e),a.parent=h,e.parent=h,this.root=h);a=a.parent;)(a=this.balance(a)).height=Math.max(a.children[0].height,a.children[1].height)+1,a.aabb=a.children[0].aabb.combine(a.children[1].aabb)}removeLeaf(e){if(this.count--,e===this.root)return void(this.root=null);const a=e.parent,t=a.parent,h=a.children[0]===e?a.children[1]:a.children[0];if(null!=t){t.children[0]===a?t.children[0]=h:t.children[1]=h,h.parent=t;let e=a;for(;e=e.parent;)(e=this.balance(e)).aabb=e.children[0].aabb.combine(e.children[1].aabb),e.height=Math.max(e.children[0].height,e.children[1].height)+1}else this.root=h,h.parent=null}balance(e){if(e.isLeaf||e.height<2)return e;const a=e,t=e.children[0],h=e.children[1],i=h.height-t.height;if(i>1){const e=h.children[0],i=h.children[1];return h.children[0]=a,h.parent=a.parent,a.parent=h,null!=h.parent?h.parent.children[0]===a?h.parent.children[0]=h:h.parent.children[1]=h:this.root=h,e.height>i.height?(h.children[1]=e,a.children[1]=i,i.parent=a,a.aabb=t.aabb.combine(i.aabb),h.aabb=a.aabb.combine(e.aabb),a.height=Math.max(t.height,i.height)+1,h.height=Math.max(a.height,e.height)+1):(h.children[1]=i,a.children[1]=e,e.parent=a,a.aabb=t.aabb.combine(e.aabb),h.aabb=a.aabb.combine(i.aabb),a.height=Math.max(t.height,e.height)+1,h.height=Math.max(a.height,i.height)+1),h}if(i<-1){const e=t.children[0],i=t.children[1];return t.children[0]=a,t.parent=a.parent,a.parent=t,null!=t.parent?t.parent.children[0]===a?t.parent.children[0]=t:t.parent.children[1]=t:this.root=t,e.height>i.height?(t.children[1]=e,a.children[0]=i,i.parent=a,a.aabb=h.aabb.combine(i.aabb),t.aabb=a.aabb.combine(e.aabb),a.height=Math.max(h.height,e.height)+1,t.height=Math.max(a.height,i.height)+1):(t.children[1]=i,a.children[0]=e,e.parent=a,a.aabb=h.aabb.combine(e.aabb),t.aabb=a.aabb.combine(i.aabb),a.height=Math.max(h.height,e.height)+1,t.height=Math.max(a.height,i.height)+1),t}return a}get height(){return null==this.root?0:root.height}}class BroadPhase{constructor(e){this.tree=new AABBTree,this.shapeToNode={},this.pairs=e,this.queryCallback=((e,a)=>{if(e.shape.body===a.shape.body)return!0;const t=e.shape.body.filterGroup,h=a.shape.body.filterGroup,i=e.shape.body.exclusionMask;if(!(t&a.shape.body.exclusionMask&&h&i))return!0;const[r,n]=Shape.order(e.shape,a.shape);return this.pairs.add({a:r,b:n}),!0})}insert(e){const a=this.tree.insert(e.aabb);a.shape=e,this.shapeToNode[e.id]=a,this.tree.query(a,this.queryCallback)}remove(e){this.tree.remove(this.shapeToNode[e.id]),delete this.shapeToNode[e.id]}flush(){this.tree.clear(),this.shapeToNode={}}collectMovedNodes(){const e=[];for(const a of Object.keys(this.shapeToNode)){const t=this.shapeToNode[a],h=t.shape,i=h.body.position.minus(h.body.prevPos);this.tree.checkMove(t,h.aabb,i)&&e.push(t)}return e}updatePairs(){for(const[e,a]of this.pairs.map){const t=this.shapeToNode[a.shapeA.id].aabb,h=this.shapeToNode[a.shapeB.id].aabb;t.test(h)||this.pairs.delete(e)}const e=this.collectMovedNodes();for(const a of e)this.tree.query(a,this.queryCallback)}query(e,a){this.tree.query({aabb:e},(e,t)=>(a(t.shape),!0))}raycast(e,a){this.tree.rayCast(e,(e,t)=>a(e,t.shape))}debugGetNodes(){return Object.keys(this.shapeToNode).map(e=>{const a=this.shapeToNode[e];return{shape:a.shape,aabb:a.aabb.clone()}})}}module.exports={Node:Node,AABBTree:AABBTree,BroadPhase:BroadPhase};"}}}},"/deps":[]}