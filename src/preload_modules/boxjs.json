{"entry":"/src/box.js","files":{"src":{"box.js":{"/code":"const fork=require(\"./framework/fork\"),Math=require(\"./framework/math\"),Solver=require(\"./framework/solver\"),Joint=require(\"./joints/joint\"),RevJoint=require(\"./joints/revjoint\"),RopeJoint=require(\"./joints/ropejoint\"),SpringJoint=require(\"./joints/springjoint\"),WheelJoint=require(\"./joints/wheeljoint\"),Body=require(\"./objects/body\"),Circle=require(\"./objects/circle\"),Polygon=require(\"./objects/polygon\"),{Shape:Shape,AABB:AABB}=require(\"./objects/shape\");module.exports={fork:fork,Math:Math,Solver:Solver,Body:Body,AABB:AABB,Shapes:{Shape:Shape,Circle:Circle,Polygon:Polygon},Joints:{Joint:Joint,RevJoint:RevJoint,RopeJoint:RopeJoint,SpringJoint:SpringJoint,WheelJoint:WheelJoint}};"},"objects":{"shape.js":{"/code":"const{Vector2D:Vector2D}=require(\"../framework/math\");let next=0;class AABB{constructor(t=0,i=0,m=0,n=0){this.min=new Vector2D(t,i),this.max=new Vector2D(m,n)}test(t){return!(this.max.x<t.min.x||this.min.x>t.max.x||this.max.y<t.min.y||this.min.y>t.max.y)}contains(t){return!(this.max.x<t.max.x||this.min.x>t.min.x||this.max.y<t.max.y||this.min.y>t.min.y)}get perimeter(){return 2*(this.max.x-this.min.x+this.max.y-this.min.y)}combine(t){return new AABB(Math.min(this.min.x,t.min.x),Math.min(this.min.y,t.min.y),Math.max(this.max.x,t.max.x),Math.max(this.max.y,t.max.y))}clone(){return new AABB(this.min.x,this.min.y,this.max.x,this.max.y)}}class Shape{constructor(){this.id=next++}static order(t,i){return t.id<i.id?[t,i]:[i,t]}}module.exports={AABB:AABB,Shape:Shape};"},"polygon.js":{"/code":"const{Vector2D:Vector2D}=require(\"../framework/math\"),MassData=require(\"./mass\"),{AABB:AABB,Shape:Shape}=require(\"./shape\"),inv3=1/3;module.exports=class t extends Shape{constructor(){super(),this.body=null,this.aabb=new AABB,this.points=[],this.norms=[]}setAsBox(t,s){return this.points.push(new Vector2D(-t,-s)),this.points.push(new Vector2D(t,-s)),this.points.push(new Vector2D(t,s)),this.points.push(new Vector2D(-t,s)),this.norms.push(new Vector2D(0,-1)),this.norms.push(new Vector2D(1,0)),this.norms.push(new Vector2D(0,1)),this.norms.push(new Vector2D(-1,0)),this.originalPoints=this.points.map(t=>t.clone()),this}set(t){if(t.length<3)throw new Error(\"Can't create polygon with fewer than 3 points\");let s=0,n=t[0].x;for(let o=1;o<t.length;o++){const i=t[o].x;i>n?(n=i,s=o):i===n&&t[o].y<t[s].y&&(s=o)}const o=[];let i=s;for(;;){o.push(i);let n=0;for(let s=1;s<t.length;s++){if(n===i){n=s;continue}const o=t[n].minus(t[i]),r=t[s].minus(t[i]),e=o.cross(r);(e<0||0===e&&r.lsqr>o.lsqr)&&(n=s)}if(i=n,n===s)break}for(const s of o)this.points.push(t[s].clone());for(let t=0;t<this.points.length;t++){const s=t+1<this.points.length?t+1:0,n=this.points[s].minus(this.points[t]);this.norms.push(n.nskew.normalize())}return this.originalPoints=this.points.map(t=>t.clone()),this}setAABB(){this.aabb.min.x=Number.MAX_VALUE,this.aabb.min.y=Number.MAX_VALUE,this.aabb.max.x=-Number.MAX_VALUE,this.aabb.max.y=-Number.MAX_VALUE;for(const t of this.points){const s=this.body.position.plus(this.body.transform.times(t));s.x<this.aabb.min.x&&(this.aabb.min.x=s.x),s.y<this.aabb.min.y&&(this.aabb.min.y=s.y),s.x>this.aabb.max.x&&(this.aabb.max.x=s.x),s.y>this.aabb.max.y&&(this.aabb.max.y=s.y)}}raycast({p1:t,p2:s,maxFraction:n}){t=this.body.transform.transpose.times(t.minus(this.body.position));const o=(s=this.body.transform.transpose.times(s.minus(this.body.position))).minus(t);let i=0,r=n,e=-1;for(let s=0;s<this.points.length;s++){const n=this.norms[s].dot(this.points[s].minus(t)),h=this.norms[s].dot(o);if(0===h&&n<0)return null;if(h<0&&n<i*h?(i=n/h,e=s):h>0&&n<r*h&&(r=n/h),r<i)return null}return e>=0?{fraction:i,normal:this.body.transform.transpose.times(this.norms[e])}:null}computeMass(t){const s=new MassData;let n=0,o=0;for(let t=0;t<this.points.length;t++){const i=t+1<this.points.length?t+1:0,r=this.points[t],e=this.points[i],h=r.cross(e),a=.5*h;n+=a,s.center.add(r.plus(e).mul(a*(1/3))),o+=1/3*.25*h*(Math.sqr(r.x)+Math.sqr(e.x)+r.x*e.x+(Math.sqr(r.y)+Math.sqr(e.y)+r.y*e.y))}return s.center.mul(1/n),s.m=t*n,s.iM=s.m?1/s.m:0,s.i=o*t,s.iI=s.i?1/s.i:0,s}getSupport(t){let s,n=-Number.MAX_VALUE;for(const o of this.points){const i=o.dot(t);i>n&&(n=i,s=o)}return s}clone(){const s=new t;for(const t of this.points)s.points.push(t.clone());for(const t of this.norms)s.norms.push(t.clone());return s}recenter(t){for(const s of this.points)s.sub(t)}};"},"mass.js":{"/code":"const{Vector2D:Vector2D}=require(\"../framework/math\");module.exports=class{constructor(){this.m=0,this.iM=0,this.i=0,this.iI=0,this.center=new Vector2D(0,0)}};"},"circle.js":{"/code":"const{Vector2D:Vector2D}=require(\"../framework/math\"),MassData=require(\"./mass\"),{AABB:AABB,Shape:Shape}=require(\"./shape\");module.exports=class s extends Shape{constructor(s){super(),this.body=null,this.aabb=new AABB,this.radius=s}setAABB(){this.aabb.max.x=this.body.position.x+this.radius,this.aabb.max.y=this.body.position.y+this.radius,this.aabb.min.x=this.body.position.x-this.radius,this.aabb.min.y=this.body.position.y-this.radius}raycast({p1:s,p2:t,maxFraction:i}){const a=s.minus(this.body.position),r=a.dot(a)-Math.sqr(this.radius),e=t.minus(s),o=a.dot(e),n=e.dot(e),h=o*o-n*r;if(h<0||n<Number.EPSILON)return null;let u=-(o+Math.sqrt(h));return u>=0&&u<=i*n?{fraction:u/=n,normal:a.plus(e.times(u)).normalize()}:null}computeMass(s){const t=new MassData;return t.center=new Vector2D(0,0),t.m=Math.PI*Math.sqr(this.radius)*s,t.iM=t.m?1/t.m:0,t.i=t.m*Math.sqr(this.radius),t.iI=t.i?1/t.i:0,t}clone(){return new s(this.radius)}};"},"body.js":{"/code":"const{Vector2D:Vector2D,Rotation:Rotation,bigG:bigG}=require(\"../framework/math\"),MassData=require(\"./mass\");module.exports=class{constructor({position:s=Vector2D.zero,angle:t,velocity:i=Vector2D.zero,angularVelocity:e,shapes:o,friction:r,restitution:n,density:a,sensor:h,static:c,filterGroup:l,exclusionList:m,onCollide:u}){this.position=Vector2D.clone(s),this.prevPos=Vector2D.clone(s),this.transform=new Rotation(t||0),this.prevAngle=t||0,this.velocity=Vector2D.clone(i),this.angularVelocity=e||0,this.force=new Vector2D(0,0),this.torque=0,this.shapes=o,this.friction=null!=r?r:.6,this.restitution=null!=n?n:.2,a=null!=a?a:1,this.mass=new MassData;for(const s of this.shapes){s.body=this;const t=s.computeMass(a);this.mass.m+=t.m,this.mass.center.add(t.center.times(t.m)),this.mass.i+=t.i}this.mass.iM=this.mass.m?1/this.mass.m:0,this.mass.iI=this.mass.i?1/this.mass.i:0,this.mass.center.mul(this.mass.iM);for(const s of this.shapes)s.recenter instanceof Function&&s.recenter(this.mass.center),s.setAABB();this.position.add(this.mass.center),c&&this.setStatic(),this.sensor=h||!1,this.setFilter(null!=l?l:1,m||[]),this.onCollide=u}get originalPosition(){const s=this.transform.times(this.mass.center);return Object.freeze(this.position.minus(s))}get originalPrevPos(){const s=new Rotation(this.prevAngle).times(this.mass.center);return Object.freeze(this.prevPos.minus(s))}applyForce(s){this.force.add(s)}applyTorque(s){this.torque+=s}applyGravity(s,t,i){const e=bigG*s*this.mass.m/Math.sqr(i),o=t.times(e);this.applyForce(o)}applyImpules(s,t){this.velocity.add(s.times(this.mass.iM)),this.angularVelocity+=this.mass.iI*t.cross(s)}setStatic(){this.mass.m=0,this.mass.iM=0,this.mass.i=0,this.mass.iI=0}setFilter(s,t){if(s>32||s<0)throw new Error(\"filter group is out of bounds (0 - 32)\");this.filterGroup=s?1<<s-1:0;let i=0;for(const s of t){if(s>32||s<2)throw new Error(\"exclusion group is out of bounds (2 - 32)\");i|=1<<s-1}this.exclusionMask=~i}};"}},"framework":{"math.js":{"/code":"function cleanAngle(t){return t-2*Math.PI*Math.trunc(t*i2pi+.5*Math.sign(t))}Math.sqr=(t=>t*t),Math.clamp=((t,i,s)=>Math.max(i,Math.min(t,s)));class Vector2D{constructor(t,i){this.x=t,this.y=i}set(t){return this.x=t.x,this.y=t.y,this}neg(){return new Vector2D(-this.x,-this.y)}add(t){return this.x+=t.x,this.y+=t.y,this}sub(t){return this.x-=t.x,this.y-=t.y,this}mul(t){return this.x*=t,this.y*=t,this}plus(t){return new Vector2D(this.x+t.x,this.y+t.y)}minus(t){return new Vector2D(this.x-t.x,this.y-t.y)}times(t){return new Vector2D(this.x*t,this.y*t)}dot(t){return this.x*t.x+this.y*t.y}cross(t){return this.x*t.y-this.y*t.x}eq(t){return this.x===t.x&&this.y===t.y}get length(){return Math.sqrt(this.lsqr)}get lsqr(){return Math.sqr(this.x)+Math.sqr(this.y)}normalize(){const t=this.length;if(t<Number.EPSILON)return this;const i=1/t;return this.mul(i),this}get skew(){return new Vector2D(-this.y,this.x)}get nskew(){return new Vector2D(this.y,-this.x)}clone(){return new Vector2D(this.x,this.y)}static clone(t){return new Vector2D(t.x,t.y)}static cross2x1(t,i){return new Vector2D(i*t.y,-i*t.x)}static cross1x2(t,i){return new Vector2D(-t*i.y,t*i.x)}static diff(t,i){return t.minus(i).length}static diffsqr(t,i){return t.minus(i).lsqr}}Vector2D.zero=new Vector2D(0,0);class Vector3D{constructor(t,i,s){this.x=t,this.y=i,this.z=s}set(t){return this.x=t.x,this.y=t.y,this.z=t.z,this}neg(){return new Vector3D(-this.x,-this.y,-this.z)}add(t){return this.x+=t.x,this.y+=t.y,this.z+=t.z,this}sub(t){return this.x-=t.x,this.y-=t.y,this.z-=t.z,this}plus(t){return new Vector3D(this.x+t.x,this.y+t.y,this.z+t.z)}minus(t){return new Vector3D(this.x-t.x,this.y-t.y,this.z-t.z)}dot(t){return this.x*t.x+this.y*t.y+this.z*t.z}cross(t){return new Vector3D(this.y*t.z-this.z*t.y,this.z*t.x-this.x*t.z,this.x*t.y-this.y*t.x)}clone(){return new Vector3D(this.x,this.y,this.z)}}class Matrix2D{constructor(t,i,s,r){this.ii=t,this.ij=i,this.ji=s,this.jj=r}set(t){return this.ii=t.ii,this.ij=t.ij,this.ji=t.ji,this.jj=t.jj,this}setRotation(t){const i=Math.cos(t),s=Math.sin(t);return this.ii=i,this.ij=-s,this.ji=s,this.jj=i,this}plus(t){return new Matrix2D(this.ii+t.ii,this.ij+t.ij,this.ji+t.ji,this.jj+t.jj)}times(t){return new Vector2D(this.ii*t.x+this.ij*t.y,this.ji*t.x+this.jj*t.y)}get determinant(){let t=this.ii*this.jj-this.ij*this.ji;return 0!==t&&(t=1/t),t}get inverse(){const t=this.determinant;return new Matrix2D(t*this.jj,-t*this.ij,-t*this.ji,t*this.ii)}get transpose(){return new Matrix2D(this.ii,this.ji,this.ij,this.jj)}solve(t){const i=this.determinant;return new Vector2D(i*(this.jj*t.x-this.ij*t.y),i*(this.ii*t.y-this.ji*t.x))}clone(){return new Matrix2D(this.ii,this.ij,this.ji,this.jj)}}Matrix2D.identity=new Matrix2D(1,0,0,1);class Rotation extends Matrix2D{constructor(t=0){super(),t=cleanAngle(t),this._r=t,this.setRotation(t)}set(t){return this.radians=t,this}get radians(){return this._r}set radians(t){t=cleanAngle(t),this.setRotation(t),this._r=t}}class Matrix3D{constructor(t,i,s,r,e,h,n,o,c){this.m=[[t,i,s],[r,e,h],[n,o,c]]}solve2(t){const i=this.m;let s=i[0][0]*i[1][1]-i[0][1]*i[1][0];return 0!==s&&(s=1/s),new Vector2D(s*(i[1][1]*t.x-i[0][1]*t.y),s*(i[0][0]*t.y-i[1][0]*t.x))}solve3(t){const i=this.m,s=new Vector3D(i[0][0],i[1][0],i[2][0]),r=new Vector3D(i[0][1],i[1][1],i[2][1]),e=new Vector3D(i[0][2],i[1][2],i[2][2]);let h=s.dot(r.cross(e));return 0!==h&&(h=1/h),new Vector3D(h*t.dot(r.cross(e)),h*s.dot(t.cross(e)),h*s.dot(r.cross(t)))}clone(){return new Matrix3D(...this.m[0],...this.m[1],...this.m[2])}}const i2pi=1/(2*Math.PI);module.exports={Vector2D:Vector2D,Vector3D:Vector3D,Matrix2D:Matrix2D,Rotation:Rotation,Matrix3D:Matrix3D,cleanAngle:cleanAngle,bigG:6.674*Math.pow(10,-11)};"},"solver.js":{"/code":"function solveBroadPhase(){for(const o of this.bodies)for(const s of o.shapes)s.setAABB();const o=this.broadPhase.getPairs();for(const s of o)this.manifolds.add(s)}function solveNarrowPhase(){for(const o of this.manifolds)o.solve(),o.isCollided||this.manifolds.delete(o)}function applyForces(o){for(const s of this.bodies)s.velocity.add(s.force.times(s.mass.iM).times(o)),s.angularVelocity+=s.torque*s.mass.iI*o}function solveVelocities(o){for(const o of this.manifolds)o.initialize();for(const o of this.manifolds)o.warmStart();for(const s of this.joints)s.initialize(o);for(let s=0;s<8;s++){for(const s of this.joints)s.applyImpulse(o);for(const o of this.manifolds)o.applyImpulse()}}function solvePositions(o){for(const s of this.bodies)s.prevPos=s.position.clone(),s.position.add(s.velocity.times(o)),s.prevAngle=s.transform.radians,s.transform.radians+=s.angularVelocity*o;for(let o=0;o<4;o++){for(const o of this.manifolds)o.positionalCorrection();for(const o of this.joints)o.positionalCorrection()}}function clearForces(){for(const o of this.bodies)o.force.x=0,o.force.y=0,o.torque=0}function collisionCallbacks(o){for(const s of this.manifolds){const i=s.shapeA,t=s.shapeB;i.body.onCollide instanceof Function&&i.body.onCollide(new ContactData(s,!1,o)),t.body.onCollide instanceof Function&&t.body.onCollide(new ContactData(s,!0,o))}}const{BroadPhase:BroadPhase}=require(\"../collision/broadphase\"),ContactData=require(\"../collision/contactdata\"),{ManifoldMap:ManifoldMap}=require(\"../collision/manifold\");module.exports=class{constructor(){this.applyG=null,this.bodies=new Set,this.joints=new Set,this.manifolds=new ManifoldMap,this.broadPhase=new BroadPhase}solve(o){this.applyG&&this.applyG([...this.bodies]),solveBroadPhase.call(this),solveNarrowPhase.call(this),applyForces.call(this,o),solveVelocities.call(this,o),solvePositions.call(this,o),clearForces.call(this),collisionCallbacks.call(this,o)}addBody(o){this.bodies.add(o);for(const s of o.shapes)this.broadPhase.insert(s)}removeBody(o){this.bodies.delete(o);for(const s of o.shapes)this.broadPhase.remove(s)}addJoint(o){this.joints.add(o)}removeJoint(o){this.joints.delete(o)}flush(){const o=[...this.bodies];return this.bodies.clear(),this.joints.clear(),this.manifolds.clear(),this.broadPhase.flush(),o}query(o,s){this.broadPhase.query(o,s)}raycast({p1:o,p2:s,callback:i,shouldCheck:t=null}){const e={p1:o,p2:s,maxFraction:1};this.broadPhase.raycast(e,(o,s)=>{if(t instanceof Function&&!t(s))return-1;const e=s.raycast(o);if(e){e.shape=s;const o=i(e);return null!=o?o:e.fraction}return-1})}debugGetNodes(){return this.broadPhase.debugGetNodes()}};"},"fork.js":{"/code":"function cloneMass(e){const o=new MassData;return o.m=e.m,o.iM=e.iM,o.i=e.i,o.iI=e.iI,o.center=e.center.clone(),o}function cloneBody(e,o){const n=new Body({position:e.position,angle:e.transform.radians,velocity:e.velocity,angularVelocity:e.angularVelocity,shapes:[],friction:e.friction,restitution:e.restitution,density:0,sensor:e.sensor,onCollide:e.onCollide});return e.shapes.forEach(e=>{const t=e.clone();t.body=n,o.set(e,t),n.shapes.push(t)}),n.prevPos=e.prevPos.clone(),n.mass=cloneMass(e.mass),n.force=e.force.clone(),n.torque=e.torque,n.filterGroup=e.filterGroup,n.exclusionMask=e.exclusionMask,n}function cloneJoint(e,o){return e.clone(o.get(e.bodyA),o.get(e.bodyB))}function cloneManifoldPoint(e){const o=new ManifoldPoint(e.point.clone(),e.lpoint.clone(),e.indexA,e.indexB,e.typeA,e.typeB);return o.bias=e.bias,o.normalImpulse=e.normalImpulse,o.tangentImpulse=e.tangentImpulse,o.normalMass=e.normalMass,o.tangentMass=e.tangentMass,o}function cloneManifold(e,o,n){const t=new Manifold(o,n);return t.type=e.type,e.contacts.forEach(e=>t.contacts.push(cloneManifoldPoint(e))),t.normal=e.normal.clone(),t.tangent=e.tangent.clone(),t.lpoint=e.lpoint.clone(),t.lnormal=e.lnormal.clone(),t.ltangent=e.ltangent.clone(),t.k=e.k.clone(),t.nMass=e.nMass?e.nMass.clone():null,t.hasSensor=e.hasSensor,t}function cloneManifoldMap(e,o){const n=new ManifoldMap;for(const t of e){const[e,a]=Shape.order(o.get(t.shapeA),o.get(t.shapeB)),s=`${e.id}:${a.id}`;n.map.set(s,cloneManifold(t,e,a))}return n}function cloneNode(e,o,n,t){const a=Object.create(Node.prototype);return a.aabb=o.aabb.clone(),a.parent=e,a.children=[],o.children.forEach(e=>{a.children.push(cloneNode(a,e,n,t))}),a.height=o.height,a.shape=n.get(o.shape),null!=a.shape&&t.set(a.shape,a),a}function cloneAABBTree(e,o,n){const t=new AABBTree;return t.count=e.count,0===t.count?t:(t.root=cloneNode(null,e.root,o,n),t)}function clonePairSet(e,o){const n=new PairSet;for(const t of e){const[e,a]=Shape.order(o.get(t.a),o.get(t.b)),s=`${e.id}:${a.id}`;n.map.set(s,{a:e,b:a})}return n}function cloneBroadPhase(e,o){const n=new BroadPhase;return n.tree=cloneAABBTree(e.tree,o,n.shapeToNode),n.pairs=clonePairSet(e.pairs,o),n}const{Node:Node,AABBTree:AABBTree,PairSet:PairSet,BroadPhase:BroadPhase}=require(\"../collision/broadphase\"),{ManifoldPoint:ManifoldPoint,Manifold:Manifold,ManifoldMap:ManifoldMap}=require(\"../collision/manifold\"),Solver=require(\"./solver\"),Body=require(\"../objects/body\"),MassData=require(\"../objects/mass\"),{Shape:Shape}=require(\"../objects/shape\");module.exports=function(e){const o=Object.create(Solver.prototype);o.applyG=e.applyG,o.bodies=new Set,o.joints=new Set;const n=new Map,t=new Map,a=new Map;return e.bodies.forEach(e=>{const a=cloneBody(e,n);t.set(e,a),o.bodies.add(a)}),e.joints.forEach(e=>{const n=cloneJoint(e,t);a.set(e,n),o.joints.add(n)}),o.manifolds=cloneManifoldMap(e.manifolds,n),o.broadPhase=cloneBroadPhase(e.broadPhase,n),{solver:o,bodyMap:t,shapeMap:n,jointMap:a}};"}},"joints":{"wheeljoint.js":{"/code":"const{Vector2D:Vector2D}=require(\"../framework/math\"),Joint=require(\"./joint\");module.exports=class s extends Joint{constructor({bodyA:s,bodyB:t,anchorA:i,anchorB:o,axis:h,frequency:a,damping:m}){super({bodyA:s,bodyB:t,anchorA:i,anchorB:o}),this.axis=h.clone(),this.frequency=a,this.damping=m,this.motorOn=!1,this.motorSpeed=0,this.motorTorqueLimit=0,this.ax=new Vector2D(0,0),this.ay=new Vector2D(0,0),this.sAx=0,this.sAy=0,this.sBx=0,this.sBy=0,this.impulse=0,this.motorImpulse=0,this.springImpulse=0,this.mass=0,this.motorMass=0,this.springMass=0,this.bias=0,this.gamma=0}initialize(s){const t=this.bodyA.transform.times(this.anchorA),i=this.bodyB.transform.times(this.anchorB),o=this.bodyA.position,h=this.bodyB.position,a=this.bodyA.mass.iM,m=this.bodyB.mass.iM,r=this.bodyA.mass.iI,e=this.bodyB.mass.iI,n=h.plus(i).sub(o.plus(t));if(this.ay=this.bodyA.transform.times(Vector2D.cross1x2(1,this.axis)),this.sAy=n.plus(t).cross(this.ay),this.sBy=i.cross(this.ay),this.mass=a+m+r*Math.sqr(this.sAy)+e*Math.sqr(this.sBy),this.mass>0&&(this.mass=1/this.mass),this.springMass=0,this.bias=0,this.gamma=0,this.frequency>0){this.ax=this.bodyA.transform.times(this.axis),this.sAx=n.plus(t).cross(this.ax),this.sBx=i.cross(this.ax);const o=a+m+r*Math.sqr(this.sAx)+e*Math.sqr(this.sBx);if(o>0){this.springMass=1/o;const t=n.dot(this.ax),i=2*Math.PI*this.frequency,h=2*this.springMass*this.damping*i,a=this.springMass*Math.sqr(i);this.gamma=s*(h+s*a),this.gamma>0&&(this.gamma=1/this.gamma),this.bias=t*s*a*this.gamma,this.springMass=o+this.gamma,this.springMass>0&&(this.springMass=1/this.springMass)}}else this.springImpulse=0;this.motorOn?(this.motorMass=r+e,this.motorMass>0&&(this.motorMass=1/this.motorMass)):(this.motorMass=0,this.motorImpulse=0);const y=this.ay.times(this.impulse).add(this.ax.times(this.springImpulse)),p=this.sAy*this.impulse+this.sAx*this.springImpulse+this.motorImpulse,d=this.sBy*this.impulse+this.sBx*this.springImpulse+this.motorImpulse;this.bodyA.velocity.sub(y.times(a)),this.bodyB.velocity.add(y.times(m)),this.bodyA.angularVelocity-=r*p,this.bodyB.angularVelocity+=e*d}applyImpulse(s){const t=this.bodyA.velocity,i=this.bodyB.velocity;let o=this.bodyA.angularVelocity,h=this.bodyB.angularVelocity;const a=this.bodyA.mass.iM,m=this.bodyB.mass.iM,r=this.bodyA.mass.iI,e=this.bodyB.mass.iI;{const s=-(this.ax.dot(i.minus(t))+this.sBx*h-this.sAx*o+this.bias+this.gamma*this.springImpulse)*this.springMass;this.springImpulse+=s;const n=this.ax.times(s),y=s*this.sAx,p=s*this.sBx;t.sub(n.times(a)),i.add(n.times(m)),o-=r*y,h+=e*p}{const t=h-o-this.motorSpeed;let i=-this.motorMass*t;const a=this.motorImpulse,m=s*this.motorTorqueLimit;this.motorImpulse=Math.clamp(this.motorImpulse+i,-m,m),o-=r*(i=this.motorImpulse-a),h+=r*i}{const s=this.ay.dot(i.minus(t))+this.sBy*h-this.sAy*o,n=-this.mass*s;this.impulse+=n;const y=this.ay.times(n),p=n*this.sAy,d=n*this.sBy;t.sub(y.times(a)),i.add(y.times(m)),o-=r*p,h+=e*d}this.bodyA.velocity.set(t),this.bodyB.velocity.set(i),this.bodyA.angularVelocity=o,this.bodyB.angularVelocity=h}positionalCorrection(){const s=this.bodyA.transform.times(this.anchorA),t=this.bodyB.transform.times(this.anchorB),i=this.bodyA.position,o=this.bodyB.position,h=this.bodyA.mass.iM,a=this.bodyB.mass.iM,m=this.bodyA.mass.iI,r=this.bodyB.mass.iI,e=o.plus(t).sub(i.plus(s)),n=this.bodyA.transform.times(Vector2D.cross1x2(1,this.axis)),y=e.plus(s).cross(this.ay),p=t.cross(this.ay),d=e.dot(n),l=h+a+m*Math.sqr(this.sAy)+r*Math.sqr(this.sBy);let c=0;0!==l&&(c=-d/l);const u=n.times(c),b=c*y,A=c*p;this.bodyA.position.sub(u.times(h)),this.bodyB.position.add(u.times(a)),this.bodyA.transform.radians-=m*b,this.bodyB.transform.radians+=r*A}setMotor(s,t=0){this.motorOn=null!=s,this.motorSpeed=s,this.motorTorqueLimit=t}clone(t,i){const o=Object.create(s.prototype);Joint.clone(o,this,t,i),o.axis=this.axis.clone(),o.frequency=this.frequency,o.damping=this.damping,o.motorOn=this.motorOn,o.motorSpeed=this.motorSpeed,o.motorTorqueLimit=this.motorTorqueLimit,o.ax=this.ax.clone(),o.ay=this.ay.clone(),o.sAx=this.sAx,o.sAy=this.sAy,o.sBx=this.sBx,o.sBy=this.sBy,o.impulse=this.impulse,o.motorImpulse=this.motorImpulse,o.springImpulse=this.springImpulse,o.mass=this.mass,o.motorMass=this.motorMass,o.springMass=this.springMass,o.bias=this.bias,o.gamma=this.gamma}};"},"joint.js":{"/code":"module.exports=class{constructor({bodyA:o,bodyB:c,anchorA:n,anchorB:s}){this.bodyA=o,this.bodyB=c,this.anchorA=n.minus(o.mass.center),this.anchorB=s.minus(c.mass.center)}static clone(o,c,n,s){o.bodyA=n,o.bodyB=s,o.anchorA=c.anchorA.clone(),o.anchorB=c.anchorB.clone()}};"},"springjoint.js":{"/code":"const{Vector2D:Vector2D}=require(\"../framework/math\"),Joint=require(\"./joint\");module.exports=class s extends Joint{constructor({bodyA:s,bodyB:t,anchorA:i,anchorB:o,length:h,frequency:a,damping:e}){super({bodyA:s,bodyB:t,anchorA:i,anchorB:o}),this.length=h,this.frequency=a,this.damping=e,this.u=new Vector2D(0,0),this.mass=0,this.impulse=0,this.gamma=0,this.bias=0}initialize(s){const t=this.bodyA.transform.times(this.anchorA),i=this.bodyB.transform.times(this.anchorB),o=this.bodyA.position,h=this.bodyB.position,a=this.bodyA.mass.iM,e=this.bodyB.mass.iM,m=this.bodyA.mass.iI,n=this.bodyB.mass.iI;this.u=h.plus(i).sub(o.plus(t));const r=this.u.length;r>.005?this.u.mul(1/r):(this.u.x=0,this.u.y=0);const c=t.cross(this.u),y=i.cross(this.u);let d=a+m*Math.sqr(c)+e+n*Math.sqr(y);if(this.mass=0!==d?1/d:0,this.frequency>0){const t=r-this.length,i=2*Math.PI*this.frequency,o=2*this.mass*this.damping*i,h=this.mass*Math.sqr(i);this.gamma=s*(o+s*h),this.gamma=0!==this.gamma?1/this.gamma:0,this.bias=t*s*h*this.gamma,d+=this.gamma,this.mass=0!==d?1/d:0}else this.gamma=0,this.bias=0;const b=this.u.times(this.impulse);this.bodyA.velocity.sub(b.times(a)),this.bodyB.velocity.add(b.times(e)),this.bodyA.angularVelocity-=m*t.cross(b),this.bodyB.angularVelocity+=n*i.cross(b)}applyImpulse(){const s=this.bodyA.transform.times(this.anchorA),t=this.bodyB.transform.times(this.anchorB),i=this.bodyA.velocity,o=this.bodyB.velocity;let h=this.bodyA.angularVelocity,a=this.bodyB.angularVelocity;const e=this.bodyA.mass.iM,m=this.bodyB.mass.iM,n=this.bodyA.mass.iI,r=this.bodyB.mass.iI,c=i.plus(Vector2D.cross1x2(h,s)),y=o.plus(Vector2D.cross1x2(a,t)),d=this.u.dot(y.minus(c)),b=-this.mass*(d+this.bias+this.gamma*this.impulse);this.impulse+=b;const l=this.u.times(b);i.sub(l.times(e)),o.add(l.times(m)),h-=n*s.cross(l),a+=r*t.cross(l),this.bodyA.velocity.set(i),this.bodyB.velocity.set(o),this.bodyA.angularVelocity=h,this.bodyB.angularVelocity=a}positionalCorrection(){if(this.frequency>0)return;const s=this.bodyA.transform.times(this.anchorA),t=this.bodyB.transform.times(this.anchorB),i=this.bodyA.position,o=this.bodyB.position,h=this.bodyA.mass.iM,a=this.bodyB.mass.iM,e=this.bodyA.mass.iI,m=this.bodyB.mass.iI,n=o.plus(t).sub(i.plus(s)),r=n.length;n.mul(1/r);const c=Math.clamp(r-this.length,-.2,.2),y=-this.mass*c,d=n.times(y);this.bodyA.position.sub(d.times(h)),this.bodyB.position.add(d.times(a)),this.bodyA.transform.radians-=e*s.cross(d),this.bodyB.transform.radians+=m*t.cross(d)}clone(t,i){const o=Object.create(s.prototype);Joint.clone(o,this,t,i),o.length=this.length,o.frequency=this.frequency,o.damping=this.damping,o.u=this.u.clone(),o.mass=this.mass,o.impulse=this.impulse,o.gamma=this.gamma,o.bias=this.bias}};"},"ropejoint.js":{"/code":"const{Vector2D:Vector2D}=require(\"../framework/math\"),Joint=require(\"./joint\");module.exports=class s extends Joint{constructor({bodyA:s,bodyB:t,anchorA:i,anchorB:o,limit:h}){super({bodyA:s,bodyB:t,anchorA:i,anchorB:o}),this.limit=h,this.u=new Vector2D(0,0),this.mass=0,this.impulse=0,this.distance=0}initialize(){const s=this.bodyA.transform.times(this.anchorA),t=this.bodyB.transform.times(this.anchorB),i=this.bodyA.position,o=this.bodyB.position,h=this.bodyA.mass.iM,e=this.bodyB.mass.iM,a=this.bodyA.mass.iI,n=this.bodyB.mass.iI;if(this.u=o.plus(t).sub(i.plus(s)),this.distance=this.u.length,this.distance<.005)return this.u.x=0,this.u.y=0,this.mass=0,void(this.impulse=0);this.u.mul(1/this.distance);const r=s.cross(this.u),m=t.cross(this.u),c=h+a*Math.sqr(r)+e+n*Math.sqr(m);this.mass=0!==c?1/c:0;const d=this.u.times(this.impulse);this.bodyA.velocity.sub(d.times(h)),this.bodyB.velocity.add(d.times(e)),this.bodyA.angularVelocity-=a*s.cross(d),this.bodyB.angularVelocity+=n*t.cross(d)}applyImpulse(s){const t=this.bodyA.transform.times(this.anchorA),i=this.bodyB.transform.times(this.anchorB),o=this.bodyA.velocity,h=this.bodyB.velocity;let e=this.bodyA.angularVelocity,a=this.bodyB.angularVelocity;const n=this.bodyA.mass.iM,r=this.bodyB.mass.iM,m=this.bodyA.mass.iI,c=this.bodyB.mass.iI,d=o.plus(Vector2D.cross1x2(e,t)),y=h.plus(Vector2D.cross1x2(a,i)),l=this.distance-this.limit;let u=this.u.dot(y.minus(d));l<0&&(u+=1/s*l);let b=-this.mass*u;const p=this.impulse;this.impulse=Math.min(0,this.impulse+b),b=this.impulse-p;const A=this.u.times(b);o.sub(A.times(n)),h.add(A.times(r)),e-=m*t.cross(A),a+=c*i.cross(A),this.bodyA.velocity.set(o),this.bodyB.velocity.set(h),this.bodyA.angularVelocity=e,this.bodyB.angularVelocity=a}positionalCorrection(){const s=this.bodyA.transform.times(this.anchorA),t=this.bodyB.transform.times(this.anchorB),i=this.bodyA.position,o=this.bodyB.position,h=this.bodyA.mass.iM,e=this.bodyB.mass.iM,a=this.bodyA.mass.iI,n=this.bodyB.mass.iI,r=o.plus(t).sub(i.plus(s)),m=r.length;r.mul(1/m);const c=Math.clamp(m-this.limit,0,.2),d=-this.mass*c,y=r.times(d);this.bodyA.position.sub(y.times(h)),this.bodyB.position.add(y.times(e)),this.bodyA.transform.radians-=a*s.cross(y),this.bodyB.transform.radians+=n*t.cross(y)}clone(t,i){const o=Object.create(s.prototype);return Joint.clone(o,this,t,i),o.limit=this.limit,o.u=this.u.clone(),o.mass=this.mass,o.impulse=this.impulse,o.distance=this.distance,o}};"},"revjoint.js":{"/code":"const{Vector2D:Vector2D,Vector3D:Vector3D,Matrix2D:Matrix2D,Matrix3D:Matrix3D,cleanAngle:cleanAngle}=require(\"../framework/math\"),Joint=require(\"./joint\");class RevJoint extends Joint{constructor({bodyA:t,bodyB:s,anchorA:i,anchorB:e,upperLimit:o,lowerLimit:a}){super({bodyA:t,bodyB:s,anchorA:i,anchorB:e}),this.mass=new Matrix3D(0,0,0,0,0,0,0,0,0),null!=o&&null!=a?this.setLimit(!0,o,a):this.setLimit(!1),this.refAngle=cleanAngle(s.transform.radians-t.transform.radians),this.cumulativeImpulse=new Vector3D(0,0,0),this.state=-1}initialize(){const t=this.bodyA.transform.times(this.anchorA),s=this.bodyB.transform.times(this.anchorB),i=this.bodyA.mass.iM,e=this.bodyB.mass.iM,o=this.bodyA.mass.iI,a=this.bodyB.mass.iI;if(this.mass.m[0][0]=i+e+Math.sqr(t.y)*o+Math.sqr(s.y)*a,this.mass.m[0][1]=-t.y*t.x*o-s.y*s.x*a,this.mass.m[0][2]=-t.y*o-s.y*a,this.mass.m[1][0]=this.mass.m[0][1],this.mass.m[1][1]=i+e+Math.sqr(t.x)*o+Math.sqr(s.x)*a,this.mass.m[1][2]=t.x*o+s.x*a,this.mass.m[2][0]=this.mass.m[0][2],this.mass.m[2][1]=this.mass.m[1][2],this.mass.m[2][2]=o+a,this.limitEnabled){let t=this.bodyB.transform.radians-this.bodyA.transform.radians;(t=cleanAngle(t-this.refAngle))<=this.lowerLimit?(this.state!==RevJoint.atLower&&(this.cumulativeImpulse.z=0),this.state=RevJoint.atLower):t>=this.upperLimit?(this.state!==RevJoint.atUpper&&(this.cumulativeImpulse.z=0),this.state=RevJoint.atUpper):(this.state=RevJoint.between,this.cumulativeImpulse.z=0)}const m=new Vector2D(this.cumulativeImpulse.x,this.cumulativeImpulse.y);this.bodyA.velocity.sub(m.times(i)),this.bodyB.velocity.add(m.times(e)),this.bodyA.angularVelocity-=o*(t.cross(m)+this.cumulativeImpulse.z),this.bodyB.angularVelocity+=a*(s.cross(m)+this.cumulativeImpulse.z)}applyImpulse(){const t=this.bodyA.transform.times(this.anchorA),s=this.bodyB.transform.times(this.anchorB),i=this.bodyA.velocity,e=this.bodyB.velocity;let o=this.bodyA.angularVelocity,a=this.bodyB.angularVelocity;const m=this.bodyA.mass.iM,h=this.bodyB.mass.iM,l=this.bodyA.mass.iI,r=this.bodyB.mass.iI;if(this.limitEnabled&&this.state!==RevJoint.between){const n=e.plus(Vector2D.cross1x2(a,s)).sub(i.plus(Vector2D.cross1x2(o,t))),u=a-o,c=new Vector3D(n.x,n.y,u),y=this.mass.solve3(c).neg();if(this.state===RevJoint.atLower)if(this.cumulativeImpulse.z+y.z<0){const t=n.neg().add({x:this.mass.m[0][2],y:this.mass.m[1][2]}).mul(this.cumulativeImpulse.z),s=this.mass.solve2(t);y.set(s),y.z=-this.cumulativeImpulse.z,this.cumulativeImpulse.x+=s.x,this.cumulativeImpulse.y+=s.y,this.cumulativeImpulse.z=0}else this.cumulativeImpulse.add(y);else if(this.cumulativeImpulse.z+y.z>0){const t=n.neg().add({x:this.mass.m[0][2],y:this.mass.m[1][2]}).mul(this.cumulativeImpulse.z),s=this.mass.solve2(t);y.set(s),y.z=-this.cumulativeImpulse.z,this.cumulativeImpulse.x+=s.x,this.cumulativeImpulse.y+=s.y,this.cumulativeImpulse.z=0}else this.cumulativeImpulse.add(y);const d=new Vector2D(y.x,y.y);i.sub(d.times(m)),e.add(d.times(h)),o-=l*(t.cross(d)+y.z),a+=r*(s.cross(d)+y.z)}else{const n=e.plus(Vector2D.cross1x2(a,s)).sub(i.plus(Vector2D.cross1x2(o,t))),u=this.mass.solve2(n.neg());this.cumulativeImpulse.x+=u.x,this.cumulativeImpulse.y+=u.y,i.sub(u.times(m)),e.add(u.times(h)),o-=l*t.cross(u),a+=r*s.cross(u)}this.bodyA.velocity.set(i),this.bodyB.velocity.set(e),this.bodyA.angularVelocity=o,this.bodyB.angularVelocity=a}positionalCorrection(){const t=this.bodyA.transform.times(this.anchorA),s=this.bodyB.transform.times(this.anchorB),i=this.bodyA.position,e=this.bodyB.position;let o=this.bodyA.transform.radians,a=this.bodyB.transform.radians;const m=this.bodyA.mass.iM,h=this.bodyB.mass.iM,l=this.bodyA.mass.iI,r=this.bodyB.mass.iI;if(this.limitEnabled&&this.state!==RevJoint.between){const t=cleanAngle(a-o-this.refAngle);let s=0;if(this.state===RevJoint.atLower){let i=t-this.lowerLimit;s=-1/(l+r)*(i=Math.clamp(i+1/90*Math.PI,-1/22.5*Math.PI,0))}else{let i=t-this.upperLimit;s=-1/(l+r)*(i=Math.clamp(i-1/90*Math.PI,0,1/22.5*Math.PI))}o-=l*s,a+=r*s}const n=e.plus(s).sub(i.plus(t)),u=new Matrix2D(m+h+l*t.y*t.y+r*s.y*s.y,-l*t.x*t.y-r*s.x*s.y,-l*t.x*t.y-r*s.x*s.y,m+h+l*t.x*t.x+r*s.x*s.x).solve(n).neg();i.sub(u.times(m)),e.add(u.times(h)),o-=l*t.cross(u),a+=r*s.cross(u),this.bodyA.position=i,this.bodyB.position=e,this.bodyA.transform.radians=o,this.bodyB.transform.radians=a}setLimit(t,s,i){if(!t)return this.limitEnabled=!1,this.upperLimit=null,void(this.lowerLimit=null);if(s>Math.PI||s<-Math.PI)throw new Error(\"upper limit out of bounts (-pi to pi)\");if(i>Math.PI||i<-Math.PI)throw new Error(\"lower limit out of bounts (-pi to pi)\");if(i>s)throw new Error(\"upper limit must be greater than lower limit\");this.limitEnabled=t,this.upperLimit=s,this.lowerLimit=i}clone(t,s){const i=Object.create(RevJoint.prototype);return Joint.clone(i,this,t,s),i.mass=this.mass.clone(),i.limitEnabled=this.limitEnabled,i.upperLimit=this.upperLimit,i.lowerLimit=this.lowerLimit,i.refAngle=this.refAngle,i.cumulativeImpulse=this.cumulativeImpulse.clone(),i.state=this.state,i}}RevJoint.atUpper=0,RevJoint.atLower=1,RevJoint.between=2,module.exports=RevJoint;"}},"collision":{"manifold.js":{"/code":"const{Vector2D:Vector2D,Matrix2D:Matrix2D}=require(\"../framework/math\");class ManifoldPoint{constructor(s,t,i,o,a,e){this.point=s||new Vector2D(0,0),this.lpoint=t||new Vector2D(0,0),this.bias=0,this.normalImpulse=0,this.tangentImpulse=0,this.normalMass=0,this.tangentMass=0,this.indexA=i,this.indexB=o,this.typeA=a,this.typeB=e}equals(s){return null!=this.indexA&&this.indexA===s.indexA&&this.indexB===s.indexB&&this.typeA===s.typeA&&this.typeB===s.typeB}flip(){[this.indexA,this.indexB]=[this.indexB,this.indexA],[this.typeA,this.typeB]=[this.typeB,this.typeA]}absorb(s){this.normalImpulse=s.normalImpulse,this.tangentImpulse=s.tangentImpulse}}ManifoldPoint.face=0,ManifoldPoint.vert=1;class Manifold{constructor(s,t){this.shapeA=s,this.shapeB=t,this.key=`${s.id}:${t.id}`,this.type=-1,this.e=Math.max(s.body.restitution,t.body.restitution),this.df=Math.sqrt(s.body.friction,t.body.friction),this.contacts=[],this.normal=new Vector2D(0,0),this.tangent=new Vector2D(0,0),this.lpoint=new Vector2D(0,0),this.lnormal=new Vector2D(0,0),this.ltangent=new Vector2D(0,0),this.k=new Matrix2D(0,0,0,0),this.nMass=null,this.hasSensor=s.body.sensor||t.body.sensor}solve(){const s=this.shapeA,t=this.shapeB;s.aabb.test(t.aabb)?Collision.getCollider(s.constructor,t.constructor)(this,s,t):this.contacts=[]}get isCollided(){return this.contacts.length>0}initialize(){if(this.hasSensor)return;const s=this.shapeA.body.mass.iM,t=this.shapeA.body.mass.iI,i=this.shapeB.body.mass.iM,o=this.shapeB.body.mass.iI,a=this.shapeA.body.velocity,e=this.shapeB.body.velocity,n=this.shapeA.body.angularVelocity,h=this.shapeB.body.angularVelocity;for(const r of this.contacts){const p=r.point.minus(this.shapeA.body.position),l=r.point.minus(this.shapeB.body.position),c=p.cross(this.normal),m=l.cross(this.normal),d=s+i+c*c*t+m*m*o;r.normalMass=d>0?1/d:0;const y=p.cross(this.tangent),u=l.cross(this.tangent),b=s+i+y*y*t+u*u*o;r.tangentMass=b>0?1/b:0,r.bias=0;const f=e.plus(Vector2D.cross1x2(h,l)).sub(a.plus(Vector2D.cross1x2(n,p))),A=this.normal.dot(f);A<-1&&(r.bias=-this.e*A)}if(2===this.contacts.length){const a=this.contacts[0].point.minus(this.shapeA.body.position),e=this.contacts[0].point.minus(this.shapeB.body.position),n=this.contacts[1].point.minus(this.shapeA.body.position),h=this.contacts[1].point.minus(this.shapeB.body.position),r=a.cross(this.normal),p=e.cross(this.normal),l=n.cross(this.normal),c=h.cross(this.normal),m=s+i+t*r*r+o*p*p,d=s+i+t*l*l+o*c*c,y=s+i+t*r*l+o*p*c;m*m<1e3*(m*d-y*y)?(this.k.ii=m,this.k.ij=y,this.k.ji=y,this.k.jj=d,this.nMass=this.k.inverse):this.contacts.pop()}}warmStart(){if(this.hasSensor)return;const s=this.shapeA.body.mass.iM,t=this.shapeA.body.mass.iI,i=this.shapeB.body.mass.iM,o=this.shapeB.body.mass.iI,a=this.shapeA.body.velocity,e=this.shapeB.body.velocity;let n=this.shapeA.body.angularVelocity,h=this.shapeB.body.angularVelocity;for(const r of this.contacts){const p=r.point.minus(this.shapeA.body.position),l=r.point.minus(this.shapeB.body.position),c=this.normal.times(r.normalImpulse).add(this.tangent.times(r.tangentImpulse));a.sub(c.times(s)),e.add(c.times(i)),n-=t*p.cross(c),h+=o*l.cross(c)}this.shapeA.body.velocity.set(a),this.shapeB.body.velocity.set(e),this.shapeA.body.angularVelocity=n,this.shapeB.body.angularVelocity=h}applyImpulse(){if(this.hasSensor)return;const s=this.shapeA.body.mass.iM,t=this.shapeA.body.mass.iI,i=this.shapeB.body.mass.iM,o=this.shapeB.body.mass.iI,a=this.shapeA.body.velocity,e=this.shapeB.body.velocity;let n=this.shapeA.body.angularVelocity,h=this.shapeB.body.angularVelocity;for(const r of this.contacts){const p=r.point.minus(this.shapeA.body.position),l=r.point.minus(this.shapeB.body.position),c=e.plus(Vector2D.cross1x2(h,l)).sub(a.plus(Vector2D.cross1x2(n,p))).dot(this.tangent);let m=r.tangentMass*-c;const d=r.normalImpulse*this.df,y=Math.clamp(r.tangentImpulse+m,-d,d);m=y-r.tangentImpulse,r.tangentImpulse=y;const u=this.tangent.times(m);a.sub(u.times(s)),e.add(u.times(i)),n-=t*p.cross(u),h+=o*l.cross(u)}if(1===this.contacts.length){const r=this.contacts[0],p=r.point.minus(this.shapeA.body.position),l=r.point.minus(this.shapeB.body.position),c=e.plus(Vector2D.cross1x2(h,l)).sub(a.plus(Vector2D.cross1x2(n,p))).dot(this.normal);let m=-r.normalMass*(c-r.bias);const d=Math.max(r.normalImpulse+m,0);m=d-r.normalImpulse,r.normalImpulse=d;const y=this.normal.times(m);a.sub(y.times(s)),e.add(y.times(i)),n-=t*p.cross(y),h+=o*l.cross(y)}else{const r=this.contacts[0],p=this.contacts[1],l=r.point.minus(this.shapeA.body.position),c=r.point.minus(this.shapeB.body.position),m=p.point.minus(this.shapeA.body.position),d=p.point.minus(this.shapeB.body.position),y=new Vector2D(r.normalImpulse,p.normalImpulse),u=e.plus(Vector2D.cross1x2(h,c)).sub(a.plus(Vector2D.cross1x2(n,l))),b=e.plus(Vector2D.cross1x2(h,d)).sub(a.plus(Vector2D.cross1x2(n,m)));let f=u.dot(this.normal),A=b.dot(this.normal);const B=new Vector2D(f-r.bias,A-p.bias).sub(this.k.times(y));for(;;){const u=this.nMass.times(B).neg();if(u.x>=0&&u.y>=0){const b=u.minus(y),f=this.normal.times(b.x),A=this.normal.times(b.y);a.sub(f.plus(A).mul(s)),e.add(f.plus(A).mul(i)),n-=t*(l.cross(f)+m.cross(A)),h+=o*(c.cross(f)+d.cross(A)),r.normalImpulse=u.x,p.normalImpulse=u.y;break}if(u.x=-r.normalMass*B.x,u.y=0,f=0,A=this.k.ji*u.x+B.yy,u.x>=0&&u.y>=0){const b=u.minus(y),f=this.normal.times(b.x),A=this.normal.times(b.y);a.sub(f.plus(A).mul(s)),e.add(f.plus(A).mul(i)),n-=t*(l.cross(f)+m.cross(A)),h+=o*(c.cross(f)+d.cross(A)),r.normalImpulse=u.x,p.normalImpulse=u.y;break}if(u.x=0,u.y=-p.normalMass*B.y,f=this.k.ij*u.y+B.x,A=0,u.y>=0&&f>=0){const b=u.minus(y),f=this.normal.times(b.x),A=this.normal.times(b.y);a.sub(f.plus(A).mul(s)),e.add(f.plus(A).mul(i)),n-=t*(l.cross(f)+m.cross(A)),h+=o*(c.cross(f)+d.cross(A)),r.normalImpulse=u.x,p.normalImpulse=u.y;break}if(u.x=0,u.y=0,f=B.x,A=B.y,f>=0&&A>=0){const b=u.minus(y),f=this.normal.times(b.x),A=this.normal.times(b.y);a.sub(f.plus(A).mul(s)),e.add(f.plus(A).mul(i)),n-=t*(l.cross(f)+m.cross(A)),h+=o*(c.cross(f)+d.cross(A)),r.normalImpulse=u.x,p.normalImpulse=u.y;break}break}}this.shapeA.body.velocity.set(a),this.shapeB.body.velocity.set(e),this.shapeA.body.angularVelocity=n,this.shapeB.body.angularVelocity=h}positionalCorrection(){if(this.hasSensor)return;const s=this.shapeA.body.mass.iM,t=this.shapeA.body.mass.iI,i=this.shapeB.body.mass.iM,o=this.shapeB.body.mass.iI,a=this.shapeA.body.position.clone(),e=this.shapeB.body.position.clone();let n=this.shapeA.body.transform.radians,h=this.shapeB.body.transform.radians,r=0;r+=this.shapeA.radius?this.shapeA.radius:0,r+=this.shapeB.radius?this.shapeB.radius:0;for(const p of this.contacts){let l,c,m;if(this.type===Manifold.circles){const s=this.lpoint.plus(this.shapeA.body.position),t=this.contacts[0].lpoint.plus(this.shapeB.body.position);m=t.minus(s).normalize(),l=s.plus(t).mul(.5),c=t.minus(s).dot(m)-r}else if(this.type===Manifold.faceA){m=this.shapeA.body.transform.times(this.lnormal);const s=this.shapeA.body.transform.times(this.lpoint).add(this.shapeA.body.position),t=this.shapeB.body.transform.times(p.lpoint).add(this.shapeB.body.position);c=t.minus(s).dot(m)-r,l=t}else if(this.type===Manifold.faceB){m=this.shapeB.body.transform.times(this.lnormal);const s=this.shapeB.body.transform.times(this.lpoint).add(this.shapeB.body.position),t=this.shapeA.body.transform.times(p.lpoint).add(this.shapeA.body.position);c=t.minus(s).dot(m)-r,l=t,m=m.neg()}const d=l.minus(this.shapeA.body.position),y=l.minus(this.shapeB.body.position),u=Math.clamp(.2*(c+.005),-.2,0),b=d.cross(m),f=y.cross(m),A=s+i+t*b*b+o*f*f,B=A>0?-u/A:0,M=m.times(B);a.sub(M.times(s)),e.add(M.times(i)),n-=t*d.cross(M),h+=o*y.cross(M)}this.shapeA.body.position.set(a),this.shapeB.body.position.set(e),this.shapeA.body.transform.radians=n,this.shapeB.body.transform.radians=h}}Manifold.circles=0,Manifold.faceA=1,Manifold.faceB=2;class ManifoldMap{constructor(){this.map=new Map}has({key:s}){return this.map.has(s)}get({key:s}){return this.map.get(s)}add({a:s,b:t}){const i=`${s.id}:${t.id}`;return this.map.has(i)||this.map.set(i,new Manifold(s,t)),this.map.get(i)}delete({key:s}){this.map.delete(s)}clear(){this.map.clear()}*[Symbol.iterator](){for(const s of this.map)yield s[1]}get size(){return this.map.size}}module.exports={ManifoldPoint:ManifoldPoint,Manifold:Manifold,ManifoldMap:ManifoldMap};const Collision=require(\"./collision.js\");"},"collision.js":{"/code":"function findSeparatingAxis(o,n){let t=-Number.MAX_VALUE,i=0;for(let s=0;s<o.points.length;s++){const e=o.body.transform.times(o.norms[s]),l=n.body.transform.transpose,r=l.times(e),a=n.getSupport(r.neg());let d=o.body.transform.times(o.points[s]).add(o.body.position);d=l.times(d.minus(n.body.position));const m=r.dot(a.minus(d));m>t&&(t=m,i=s)}return{index:i,distance:t}}function findIncidentEdge(o,n,t){let i=o.norms[t];i=o.body.transform.times(i),i=n.body.transform.transpose.times(i);let s=0,e=Number.MAX_VALUE;for(let o=0;o<n.points.length;o++){const t=i.dot(n.norms[o]);t<e&&(e=t,s=o)}const l=s+1>=n.points.length?0:s+1;return[new ManifoldPoint(n.body.transform.times(n.points[s]).add(n.body.position),n.points[s],t,s,ManifoldPoint.face,ManifoldPoint.vert),new ManifoldPoint(n.body.transform.times(n.points[l]).add(n.body.position),n.points[l],t,l,ManifoldPoint.face,ManifoldPoint.vert)]}function clipPoints(o,n,t,i){const s=[],e=n.dot(o[0].point)-t,l=n.dot(o[1].point)-t;if(e<=0&&s.push(o[0]),l<=0&&s.push(o[1]),e*l<0){const n=e/(e-l);s.push(new ManifoldPoint(o[0].point.plus(o[1].point.minus(o[0].point).mul(n)),o[0].lpoint.plus(o[1].lpoint.minus(o[0].lpoint).mul(n)),i,o[0].indexB,ManifoldPoint.vert,ManifoldPoint.face))}return s}function polyToPoly(o,n,t){const i=o.contacts;o.contacts=[];const{index:s,distance:e}=findSeparatingAxis(n,t);if(e>0)return;const{index:l,distance:r}=findSeparatingAxis(t,n);if(r>0)return;let a,d,m,c;r>e+5e-4?(m=t,c=n,a=l,o.type=Manifold.faceB,d=!0):(m=n,c=t,a=s,o.type=Manifold.faceA,d=!1);const p=findIncidentEdge(m,c,a),f=a,u=f+1>=m.points.length?0:f+1;let y=m.points[f],b=m.points[u];o.ltangent=b.minus(y).normalize(),o.lnormal=Vector2D.cross2x1(o.ltangent,1),o.lpoint=y.plus(b).mul(.5);const g=m.body.transform.times(o.ltangent),M=Vector2D.cross2x1(g,1);y=m.body.transform.times(y).add(m.body.position),b=m.body.transform.times(b).add(m.body.position);const P=M.dot(y),h=-g.dot(y),C=g.dot(b);let w=clipPoints(p,g.neg(),h,f);if(!(w.length<2||(w=clipPoints(w,g,C,u)).count<2)){for(const n of w)if(M.dot(n.point)-P<=0){d&&n.flip();for(const o of i)n.equals(o)&&n.absorb(o);o.contacts.push(n)}o.normal=d?M.neg():M,o.tangent=d?g.neg():g}}function circleToCircle(o,n,t){o.contacts=[],o.normal=t.body.position.minus(n.body.position);const i=o.normal.lsqr,s=n.radius+t.radius;i>Math.sqr(s)||(o.contacts.push(new ManifoldPoint(t.body.position.plus(n.body.position).mul(.5))),o.type=Manifold.circles,o.normal.normalize(),o.tangent=Vector2D.cross2x1(o.normal,1))}function circleToPoly(o,n,t){o.contacts=[];const i=t.body.transform.transpose.times(n.body.position.minus(t.body.position));let s=-Number.MAX_VALUE,e=0;for(let o=0;o<t.points.length;o++){const l=t.norms[o].dot(i.minus(t.points[o]));if(l>n.radius)return;l>s&&(s=l,e=o)}const l=e+1<t.points.length?e+1:0,r=t.points[e],a=t.points[l];if(s<Number.EPSILON)o.type=Manifold.faceB,o.lnormal=t.norms[e],o.lpoint=r.plus(a).mul(.5),o.normal=t.body.transform.times(t.norms[e]).neg(),o.contacts.push(new ManifoldPoint(o.normal.times(n.radius).add(n.body.position)));else{const s=i.minus(r).dot(a.minus(r)),l=i.minus(a).dot(r.minus(a));if(s<=0){if(i.minus(r).lsqr>Math.sqr(n.radius))return;o.type=Manifold.faceB,o.lnormal=i.minus(r).normalize(),o.normal=t.body.transform.times(o.lnormal).neg().normalize(),o.lpoint=r,o.contacts.push(new ManifoldPoint(t.body.transform.times(r).add(t.body.position)))}else if(l<=0){if(i.minus(a).lsqr>Math.sqr(n.radius))return;o.type=Manifold.faceB,o.lnormal=i.minus(a).normalize(),o.normal=t.body.transform.times(o.lnormal).neg().normalize(),o.lpoint=a,o.contacts.push(new ManifoldPoint(t.body.transform.times(a).add(t.body.position)))}else{if(o.lpoint=r.plus(a).mul(.5),o.lnormal=t.norms[e],i.minus(o.lpoint).dot(o.lnormal)>n.radius)return;o.normal=t.body.transform.times(o.lnormal).neg().normalize(),o.type=Manifold.faceB,o.contacts.push(new ManifoldPoint(o.normal.times(n.radius).add(n.body.position)))}}o.tangent=Vector2D.cross2x1(o.normal,1)}function polyToCircle(o,n,t){circleToPoly(o,t,n),o.type=Manifold.faceA,o.normal=o.normal.neg(),o.tangent=o.tangent.neg()}const{Vector2D:Vector2D}=require(\"../framework/math\"),{Manifold:Manifold,ManifoldPoint:ManifoldPoint}=require(\"./manifold\"),Polygon=require(\"../objects/polygon\"),Circle=require(\"../objects/circle\"),baseMap=new Map;class Collision{static getCollider(o,n){if(!baseMap.has(o))throw{message:\"collider not set for type combination\",type1:o,type2:n};if(!baseMap.get(o).has(n))throw{message:\"collider not set for type combination\",type1:o,type2:n};return baseMap.get(o).get(n)}static newCollider(o,n,t){baseMap.has(o)||baseMap.set(o,new Map),baseMap.get(o).set(n,t)}}module.exports=Collision,Collision.newCollider(Polygon,Polygon,polyToPoly),Collision.newCollider(Circle,Circle,circleToCircle),Collision.newCollider(Circle,Polygon,circleToPoly),Collision.newCollider(Polygon,Circle,polyToCircle);"},"contactdata.js":{"/code":"module.exports=class{constructor(s,e,t){if(this.shape=e?s.shapeB:s.shapeA,this.otherShape=e?s.shapeA:s.shapeB,this.normalForces=[],this.tangentForces=[],!s.hasSensor)for(const n of s.contacts){let o=s.normal.times(n.normalImpulse/t),a=s.tangent.times(n.tangentImpulse/t);e&&(o=o.neg(),a=a.neg()),this.normalForces.push(o),this.tangentForces.push(a)}}};"},"broadphase.js":{"/code":"function makeFatAABB(e){return new AABB(e.min.x-.2,e.min.y-.2,e.max.x+.2,e.max.y+.2)}function queryCallback(e,t){if(e.shape.body===t.shape.body)return!0;const a=e.shape.body.filterGroup,i=t.shape.body.filterGroup,h=e.shape.body.exclusionMask;if(!(a&t.shape.body.exclusionMask&&i&h))return!0;const[r,n]=Shape.order(e.shape,t.shape);return this.pairs.add({a:r,b:n}),!0}const{Vector2D:Vector2D}=require(\"../framework/math\"),{AABB:AABB,Shape:Shape}=require(\"../objects/shape\");class Node{constructor(e,t=null,a=0){this.aabb=makeFatAABB(e),this.parent=t,this.children=[],this.height=a,this.shape=null}get isLeaf(){return 0===this.children.length}}class AABBTree{constructor(){this.count=0,this.root=null}insert(e){const t=new Node(e);return this.insertLeaf(t),t}remove(e){this.removeLeaf(e)}clear(){this.count=0,this.root=null}checkMove(e,t,a){if(e.aabb.contains(t))return!1;e.aabb=makeFatAABB(t);const i=a.times(2);return(i.x<0?e.aabb.min:e.aabb.max).x+=i.x,(i.y<0?e.aabb.min:e.aabb.max).y+=i.y,this.removeLeaf(e),this.insertLeaf(e),!0}query(e,t){const a=[this.root];for(;a.length>0;){const i=a.pop();if(null!=i&&i.aabb.test(e.aabb)){if(i.isLeaf&&!t(e,i))return;a.push(i.children[0],i.children[1])}}}rayCast({p1:e,p2:t,maxFraction:a},i){const h=t.minus(e).normalize(),r=Vector2D.cross1x2(1,h),n=new Vector2D(Math.abs(r.x),Math.abs(r.y));let s=e.plus(t.minus(e).mul(a)),o=new AABB(Math.min(e.x,s.x),Math.min(e.y,s.y),Math.max(e.x,s.x),Math.max(e.y,s.y));const b=[this.root];for(;b.length>0;){const h=b.pop();if(null==h||!h.aabb.test(o))continue;const c=h.aabb.min.plus(h.aabb.max).mul(.5),l=h.aabb.max.minus(h.aabb.min).mul(.5);if(!(Math.abs(r.dot(e.minus(c)))-n.dot(l)>0))if(h.isLeaf){const r=i({p1:e,p2:t,maxFraction:a},h);if(0===r)return;r>0&&(a=r,s=e.plus(t.minus(e).mul(a)),o=new AABB(Math.min(e.x,s.x),Math.min(e.y,s.y),Math.max(e.x,s.x),Math.max(e.y,s.y)))}else b.push(h.children[0],h.children[1])}}insertLeaf(e){if(this.count++,null===this.root)return this.root=e,void(this.root.parent=null);let t=this.root;for(;!t.isLeaf;){const a=t.aabb.perimeter,i=e.aabb.combine(t.aabb).perimeter,h=2*i,r=2*(i-a);let n;if(t.children[0].isLeaf)n=e.aabb.combine(t.children[0].aabb).perimeter+r;else{const a=t.children[0].aabb.perimeter;n=e.aabb.combine(t.children[0].aabb).perimeter-a+r}let s;if(t.children[1].isLeaf)s=e.aabb.combine(t.children[1].aabb).perimeter+r;else{const a=t.children[1].aabb.perimeter;s=e.aabb.combine(t.children[1].aabb).perimeter-a+r}if(h<n&&h<s)break;t=n<s?t.children[0]:t.children[1]}const a=t.parent,i=new Node(e.aabb.combine(t.aabb),a,t.height+1);for(null!=a?(a.children[0]===t?a.children[0]=i:a.children[1]=i,i.children.push(t,e),t.parent=i,e.parent=i):(i.children.push(t,e),t.parent=i,e.parent=i,this.root=i);t=t.parent;)(t=this.balance(t)).height=Math.max(t.children[0].height,t.children[1].height)+1,t.aabb=t.children[0].aabb.combine(t.children[1].aabb)}removeLeaf(e){if(this.count--,e===this.root)return void(this.root=null);const t=e.parent,a=t.parent,i=t.children[0]===e?t.children[1]:t.children[0];if(null!=a){a.children[0]===t?a.children[0]=i:a.children[1]=i,i.parent=a;let e=t;for(;e=e.parent;)(e=this.balance(e)).aabb=e.children[0].aabb.combine(e.children[1].aabb),e.height=Math.max(e.children[0].height,e.children[1].height)+1}else this.root=i,i.parent=null}balance(e){if(e.isLeaf||e.height<2)return e;const t=e,a=e.children[0],i=e.children[1],h=i.height-a.height;if(h>1){const e=i.children[0],h=i.children[1];return i.children[0]=t,i.parent=t.parent,t.parent=i,null!=i.parent?i.parent.children[0]===t?i.parent.children[0]=i:i.parent.children[1]=i:this.root=i,e.height>h.height?(i.children[1]=e,t.children[1]=h,h.parent=t,t.aabb=a.aabb.combine(h.aabb),i.aabb=t.aabb.combine(e.aabb),t.height=Math.max(a.height,h.height)+1,i.height=Math.max(t.height,e.height)+1):(i.children[1]=h,t.children[1]=e,e.parent=t,t.aabb=a.aabb.combine(e.aabb),i.aabb=t.aabb.combine(h.aabb),t.height=Math.max(a.height,e.height)+1,i.height=Math.max(t.height,h.height)+1),i}if(h<-1){const e=a.children[0],h=a.children[1];return a.children[0]=t,a.parent=t.parent,t.parent=a,null!=a.parent?a.parent.children[0]===t?a.parent.children[0]=a:a.parent.children[1]=a:this.root=a,e.height>h.height?(a.children[1]=e,t.children[0]=h,h.parent=t,t.aabb=i.aabb.combine(h.aabb),a.aabb=t.aabb.combine(e.aabb),t.height=Math.max(i.height,e.height)+1,a.height=Math.max(t.height,h.height)+1):(a.children[1]=h,t.children[0]=e,e.parent=t,t.aabb=i.aabb.combine(e.aabb),a.aabb=t.aabb.combine(h.aabb),t.height=Math.max(i.height,e.height)+1,a.height=Math.max(t.height,h.height)+1),a}return t}get height(){return null==this.root?0:root.height}}class PairSet{constructor(){this.map=new Map}has({a:e,b:t}){const a=`${e.id}:${t.id}`;return this.map.has(a)}get({a:e,b:t}){const a=`${e.id}:${t.id}`;return this.map.get(a)}add({a:e,b:t}){const a=`${e.id}:${t.id}`;return this.map.has(a)||this.map.set(a,{a:e,b:t}),this.map.get(a)}delete({a:e,b:t}){const a=`${e.id}:${t.id}`;this.map.delete(a)}clear(){this.map.clear()}*[Symbol.iterator](){for(const e of this.map)yield e[1]}get size(){return this.map.size}}class BroadPhase{constructor(){this.tree=new AABBTree,this.shapeToNode=new Map,this.pairs=new PairSet,this.queryCallback=queryCallback.bind(this)}insert(e){const t=this.tree.insert(e.aabb);t.shape=e,this.shapeToNode.set(e,t),this.tree.query(t,this.queryCallback)}remove(e){this.tree.remove(this.shapeToNode.get(e)),this.shapeToNode.delete(e)}flush(){this.tree.clear(),this.shapeToNode.clear(),this.pairs.clear()}collectMovedNodes(){const e=[];for(const t of this.shapeToNode){const a=t[0],i=t[1],h=a.body.position.minus(a.body.prevPos);this.tree.checkMove(i,a.aabb,h)&&e.push(i)}return e}getPairs(){const e=this.collectMovedNodes();for(const t of e)this.tree.query(t,this.queryCallback);const t=[...this.pairs];for(const e of t){const t=this.shapeToNode.get(e.a).aabb,a=this.shapeToNode.get(e.b).aabb;t.test(a)||this.pairs.delete(e)}return this.pairs}query(e,t){this.tree.query({aabb:e},(e,a)=>(t(a.shape),!0))}raycast(e,t){this.tree.rayCast(e,(e,a)=>t(e,a.shape))}debugGetNodes(){return[...this.shapeToNode].map(e=>e[1].aabb.clone())}}module.exports={Node:Node,AABBTree:AABBTree,PairSet:PairSet,BroadPhase:BroadPhase};"}}}},"/deps":[]}